{
  "hash": "979e2763b90c66e19607c6941b5caba2",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Julia for R users\n---\n\n\n\n> I know a lot of R and can do my daily job with it. Why should I learn Julia?\n\nIn my case, I was looking for some adventure. Haskell seemed too hard, Python too normal. So I went on a journey to learn Julia and was very happy with what I discovered.\n\nI love R, it is my breadwinner (and has been for the past 6 years), and I know some of its limitations. So below is a (biased) list of features that may interest you in trying Julia:\n\n## You can run R inside of Julia\n\nNot sure where to begin in Julia? Start with R!\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing RCall;\n\nR\"\"\"\nmedian(1:5)\n\"\"\"\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\nRObject{IntSxp}\n[1] 3\n```\n:::\n:::\n\n\nYou can even pass objects from Julia to R:\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nx = [1:5;]\n\n@rput x\n\nR\"median(x)\"\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\nRObject{IntSxp}\n[1] 3\n```\n:::\n:::\n\n\nThis quarto notebook is actually run using RCall! See [RCall docs](https://juliainterop.github.io/RCall.jl/stable/gettingstarted/) for more details.\n\nYou can see some differences between R and Julia [here](https://docs.julialang.org/en/v1/manual/noteworthy-differences/#Noteworthy-differences-from-R).\n\n## There is a tidyverse in Julia and it is awesome\n\n[Tidier.jl](https://tidierorg.github.io/Tidier.jl/dev/) is a data analysis package inspired by R's tidyverse and crafted specifically for Julia. It is made with the macro magic described below. Behind the scenes, it is transformed in usual `Dataframes.jl` code.\n\nHere's an example from TidierData docs:\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nusing TidierData\nusing RDatasets\n\nmovies = dataset(\"ggplot2\", \"movies\");\n\n@chain movies begin\n    @mutate(Budget = Budget / 1_000_000)\n    @filter(Budget >= mean(skipmissing(Budget)))\n    @select(Title, Budget)\n    @slice(1:5)\nend\n```\n:::\n\n\nIt looks like `dplyr` code with `@`s.\n\n## Fast Julia code is written in Julia; fast R code is not written in R\n\nIn R, whenever you need some *really* fast code (as fast as you would get in C), you have to use C or Fortran code. R is simply slow. If you need speed in R, you will have to find a package that already implements what you need or learn C/Fortran, use RCpp and pray.\n\n![`stringi` package sourcecode.](images/stringi-code.png)\n\nIn Julia, you won't need other language to get speed close to C. That's way they say that Julia [solves the two language problem](https://juliadatascience.io/julia_accomplish#sec:two_language). Julia packages are almost always 100% Julia, which means that you can look to its sourcecode and learn a lot.\n\n![Images that make you cry: the deep learning package [Flux.jl](https://github.com/FluxML/Flux.jl).](images/flux.png)\n\nThis is specially interesting if you read Julia Base sourcecode! How does Julia define the maximum of a vector? Type\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\n@edit maximum([1:5;])\n```\n:::\n\n\nand you will see this:\n\n![The sourcecode of the function maximum applied to a vector.](images/maximum-sourcecode.png)\n\nIt takes some time to grasp the meaning, but in the end it says \"apply a mapreduce into the vector, using the max function on each pair of numbers\". In R, the sourcecode is a sad `.Primitive(\"max\")`.\n\n\n## No need to vectorize code; loops, maps and broadcast are fast enough\n\nTired of writing loops? Julia has a special notation `.` (yes, a dot) to apply *any* function to a vector/array/iterable-object; this is called [*broadcasting*](https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting). For example, you can apply the `power2` function in a vector as easy as\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n#julia\n# define power2 for numbers\npower2(x) = x^2;\n\n# apply in vectors\npower2.(1:10)\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n10-element Vector{Int64}:\n   1\n   4\n   9\n  16\n  25\n  36\n  49\n  64\n  81\n 100\n```\n:::\n:::\n\n\nor in a matrix\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\n#julia\nX = reshape([1:16;], (4, 4))\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\n#julia\npower2.(X)\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n4×4 Matrix{Int64}:\n  1  25   81  169\n  4  36  100  196\n  9  49  121  225\n 16  64  144  256\n```\n:::\n:::\n\n\nWhen using infix functions like `+` or `=`, you put the dot before the operator, as in\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\n#julia\n[1:5;] .+ 10\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n5-element Vector{Int64}:\n 11\n 12\n 13\n 14\n 15\n```\n:::\n:::\n\n\nIn R, you always try to avoid loops because they are *slow*. Suppose you have a vector and want to sum 1 to every entry. As an experienced R programmer, you look for a vectorized approach:\n\n```r\n# R\nf1_vec = function(x) {\n    y = x + 1\n}\n```\n\ninstead of a loop\n\n```r\n# R\nf1_loop = function(x) {\n    y = x\n    for (i in seq_along(x)) y[i] = x[i] + 1\n    y\n}\n```\n\nor a even a `purrr::map` approach (if you are in a functional programming mood)\n\n```r\n#R\nf1_map = function(x) {\n    purrr::map_dbl(x, \\(xi) xi + 1)\n}\n```\n\nbecause the first options is faster. We can see the difference:\n\n```r\n# R\nx = 1:100000\n\nbench::mark(\n    f1_vec(x)\n    ,f1_loop(x)\n    ,f1_map(x)\n    ,relative = TRUE\n)\n```\n\n::: {.cell execution_count=9}\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\nRObject{VecSxp}\n# A tibble: 3 × 13\n  expression   min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time\n  <bch:expr> <dbl>  <dbl>     <dbl>     <dbl>    <dbl> <int> <dbl>   <bch:tm>\n1 f1_vec(x)    1      1       125.       1.50    11.0    763    11      500ms\n2 f1_loop(x)  43.9   12.6      12.1      1.50     1       74     1      501ms\n3 f1_map(x)  559.   151.        1        1        7.83     7     9      575ms\n# ℹ 4 more variables: result <list>, memory <list>, time <list>, gc <list>\n```\n:::\n:::\n\n\nIn my machine, the loop is ~40x slower and the map ~500x slower than the vectorized version.\n\nThe problem is when the function you want to apply have no vectorized form.\n\nIn Julia, the three approachs are similar:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\n#julia\nf1_vec(x) = x .+ 1;\n\nfunction f1_loop(x)\n    y = similar(x)\n    @inbounds for i ∈ eachindex(x) y[i] = x[i] + 1 end\n    y\nend;\n\nfunction f1_map(x)\n    map(x) do xi\n        xi + 1 \n    end\nend;\n```\n:::\n\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\n#julia\nusing BenchmarkTools;\nx = [1:100000;];\n\n@benchmark f1_vec($x)\n```\n:::\n\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\n#julia\n@benchmark f1_loop($x)\n```\n:::\n\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\n#julia\n@benchmark f1_map($x)\n```\n:::\n\n\nThis means that in Julia it is usual to *define a function using a scalar type* (a Number like Float64/Int or a String) *and then use broadcast* to apply the function to vectors/matrices/etc. No need to create vectorized forms of functions anymore!\n\n## The compiler is your friend\n\nSometimes you write code that won't make your parents proud. Suppose you create a function that sums all the numbers from 1 to `n`:\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nfunction f_sum(n)\n    s = 0\n    for i in 1:n\n        s += i\n    end\n\n    s\nend;\n```\n:::\n\n\nIn R, the language will obediently execute each iteration of the loop, as you demanded. You are the boss.\n\nBut in Julia, we have this curious phenomena:\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\n@time f_sum(100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.000001 seconds\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n5050\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\n@time f_sum(100_000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.000001 seconds\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n5000050000\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\n@time f_sum(100_000_000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.000001 seconds\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\n5000000050000000\n```\n:::\n:::\n\n\nHow is it possible that it took the same time for 100 iterations and 100 million? The magic is the compiler: it understood that what you are doing is the sum of the terms of an [arithmetic progression](https://en.wikipedia.org/wiki/Arithmetic_progression). The legend says that Gauss deduced the formula for its sum, and the compiler did the same for you. No need to be as smart as Gauss while using Julia!\n\nJulia is a [just-in-time (JIT) compiled language](https://docs.julialang.org/en/v1/devdocs/aot/), which means that each function is compiled when you first execute it. The \"time to first compile\" was a problem in the past, but from Julia 1.8 onwards it is not a big deal.\n\n\n## Multiple dispatch and type system\n\nA type system is a way to organize data types within an hierarchy. Think of it as mathematical sets: you have the real numbers, and inside it are the rationals, the integers and so on. Each one of these types store data into memory in a different manner (integers can be stored more efficiently than arbitrary real numbers, for example). Julia has a really nice [type system](https://docs.julialang.org/en/v1/manual/types/). Let's see some examples to better understand it.\n\nConsider the `print` function in R. It is a *generic* function, which means that its behaviour depends on the class/type of its first argument. This can be seen when we look to its misterious source code:\n\n![The `print` function sourcecode.](images/print-code.png)\n\nwhich means that `print` will use several `methods` (implementations/pieces-of-code), one for each class/type. Actually, R just creates a different function for each class, with the pattern `{function}.{class}`: \n\n![Each method/implementation of the generic function `print`.](images/print-methods.png)\n\nIn Julia, *every function is generic*. This means that we can use the same function name and define different behaviours/implementations for each combination of classes/types of its arguments. We saw above the implementation of the `maximum` function in Julia for an arbitrary vector of numbers. But what if the vector is of a different kind, which is easier to determine the maximum?\n\nTake, for example, the object\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nx = 1:10\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\n1:10\n```\n:::\n:::\n\n\nIt is *not* a vector (to create a usual vector from 1 to 10, you type `[1:10;]`). Actually, its type is\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\nUnitRange{Int64}\n```\n:::\n:::\n\n\nand its type hierarchy is\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\nBase.show_supertypes(typeof(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnitRange{Int64} <: AbstractUnitRange{Int64} <: OrdinalRange{Int64, Int64} <: AbstractRange{Int64} <: AbstractVector{Int64} <: Any\n```\n:::\n:::\n\n\nSo `x` is a much simpler object than a vector: it is an increasing sequence of integer numbers, each 1 unity bigger than the previous one. It makes sense then that the `maximum` function can be defined much more simpler for an object of type `UnitRange{Int64}`: the biggest element is always the last.\n\nIf you look at the sourcecode\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\n@edit maximum(1:10)\n```\n:::\n\n\nyou will get\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\nmaximum(r::AbstractUnitRange) = isempty(r) ? throw(ArgumentError(\"range must be non-empty\")) : last(r)\n```\n:::\n\n\nwhich is exactly what we thought. The function `last` is defined for every element children of type `AbstractUnitRange`, and so `maximum` is well defined and performant.\n\nIn summary: Julia has an arbitrary `maximum` function for arbitrary vectors, but has specialized methods for some other specific types. This is a common pattern in Julia, and much of its performance depends on this. \n\n\n## Macros rewrite code without typing\n\n[Macros](https://docs.julialang.org/en/v1/manual/metaprogramming/) are one of the most powerful tools in Julia. They rewrite your code before executing it: it is a metaprogramming technique. When creating macros, you will have to understand how a bunch of characters are interpreted by the language and executed as code. This means that macros can rewrite pieces of code and add functionalities that are not possible simply with functions.\n\nWe already used some macros on this notebook; they all start with the `@` symbol. \n\nHow much time does it take to calculate the sin of a million numbers?\n\n::: {.cell execution_count=23}\n``` {.julia .cell-code}\n@time sin.(1:1_000_000);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.018330 seconds (2 allocations: 7.629 MiB)\n```\n:::\n:::\n\n\nDo you have a loop and want to see a progress bar? No need to change the code inside the loop:\n\n::: {.cell execution_count=24}\n``` {.julia .cell-code}\nusing ProgressMeter;\n\n@showprogress for i in 1:10\n    sleep(0.1)\nend\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\rProgress:  20%|████████▎                                |  ETA: 0:00:01\rProgress:  30%|████████████▎                            |  ETA: 0:00:01\rProgress:  40%|████████████████▍                        |  ETA: 0:00:01\rProgress:  50%|████████████████████▌                    |  ETA: 0:00:01\rProgress:  60%|████████████████████████▋                |  ETA: 0:00:00\rProgress:  70%|████████████████████████████▊            |  ETA: 0:00:00\rProgress:  80%|████████████████████████████████▊        |  ETA: 0:00:00\rProgress:  90%|████████████████████████████████████▉    |  ETA: 0:00:00\rProgress: 100%|█████████████████████████████████████████| Time: 0:00:01\n```\n:::\n:::\n\n\nAs we've seen, even the tidyverse could be recreated in Julia using macros!\n\n\n## Multithreading is trivial\n\n## Modules and packages are a joy to use\n\nIn R, you have 2 options to call a function from another package:\n\n- use `library(PACKAGE)` and then import *every* function from PACKAGE to your namespace;\n- use `PACKAGE::FUNCTION` every time you want to use a function.\n\nPackages like [`box`](https://klmr.me/box/) are a more \"Pythonesque\" approach to importing libraries.\n\nIn Julia, you have all these for free:\n\n- a\n- b\n- c\n\nThere is also the possibility to create modules inside modules (which are like packages inside packages). For example, if you have a package to train machine learning models, you can have a module about Metrics, another one with Models and so on. Importing then can be done with\n\n::: {.cell execution_count=25}\n``` {.julia .cell-code}\nusing MyPackage.Metrics\n\n# or\nimport MyPackage.Models as MD\n\nMD.model1(etc)\n```\n:::\n\n\n## Math symbols for the math enthusiasts\n\nExamples of correct Julia code:\n\n::: {.cell execution_count=26}\n``` {.julia .cell-code}\n[1, 2] ∩ [2, 3]\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\n1-element Vector{Int64}:\n 2\n```\n:::\n:::\n\n\n::: {.cell execution_count=27}\n``` {.julia .cell-code}\n2 ∈ [2, 3]\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\ntrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=28}\n``` {.julia .cell-code}\nf(r) = π*r^2\n\nf(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\n28.274333882308138\n```\n:::\n:::\n\n\n::: {.cell execution_count=29}\n``` {.julia .cell-code}\n# Euler's identity\nℯ^(im * π) + 1 |> round\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\n0.0 + 0.0im\n```\n:::\n:::\n\n\n",
    "supporting": [
      "julia-for-r-users_files/figure-pdf"
    ],
    "filters": []
  }
}