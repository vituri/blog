[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Main",
    "section": "",
    "text": "Gathered thoughts."
  },
  {
    "objectID": "posts/future-history/future-history.html",
    "href": "posts/future-history/future-history.html",
    "title": "“História do futuro” e os limites da imaginação",
    "section": "",
    "text": "Se o melhor jeito de prever o futuro é inventá-lo, Olaf Stapledon foi um dos maiores inventores da literatura.\nEm 1930, Stapledon publicou “Last and First men”, um livro de “história do futuro” que conta a trajetória da humanidade desde a primeira guerra mundial até sua extinção em Netuno, 2 bilhões de anos no futuro, após uma supernova destruir o sistema Solar. Stapledon descreve em detalhes cada uma das 18 espécies pós-humanas: como elas mudaram de aparência física e perderam a inteligência; como, milhões de anos depois, redescobriram a ciência, modificaram a si mesmos com engenharia genética, chegando até a criar uma nova espécie artificial. Porém não é sobre esse livro que falarei hoje.\n\n\n\nFicção científica e suas capas cabulosas\n\n\nEm 1937 Stapledon publica “Star maker”, cujo enredo muito mais ambiciosa faz “Last and first men” parecer um minúsculo continho: narrar a história inteira do Universo e dos seres vivos. O livro começa de maneira inusitada quando um homem casado vai dar um passeio à noite perto de sua casa pensando sobre o amor, o casamento, a união das almas, o sentido da vida, quando de repente vira um ser incorpóreo e começa a boiar no espaço, vendo a Terra se afastando rapidamente.\n\nBut now irrationally I was seized with a strange worship, not, surely of the star, that mere furnace which mere distance falsely sanctified, but of something other, which the dire contrast of the star and us signified to the heart. Yet what, what could thus be signified? Intellect, peering beyond the star, discovered no Star Maker, but only darkness; no Love, no Power even, but only Nothing. And yet the heart praised.\n\nApós um tempo indeterminado (dias? anos? milênios?) vivendo a sós com seus pensamentos, pensando que estava morto e preso numa espécie de limbo, o protagonista descobre como “voar” pelo espaço com a força do pensamento.\n\nThe sun was now but one among the other bright stars. Nothing changed. Was I doomed to hang thus for ever out in space, a bodiless view-point? Had I died? Was this my punishment for a singularly ineffectual life? Was this the penalty of an inveterate will to remain detached from human affairs and passions and prejudices?\n\n\n\n\nA bolota mágica\n\n\nCrendo-se um “enviado das estrelas” e sem chance de encontrar a Terra no meio de bilhões de estrelas, ele resolve investigar um a um dos planetas que encontra.\n\nI now hurried from star to star, a lost dog looking for its master. I rushed hither and thither, intent on finding a sun with planets, and among those planets my home.\n\nPercebe então que as estrelas ficaram mais claras e brilhantes, e conclui que na verdade voltou alguns bilhões de anos no tempo. Após mais alguns milênios à deriva, descobre finalmente um planeta habitado por uma espécie inteligente.\nStapledon descreve em detalhes como essa espécie se comunicava com cheiros, o sistema político, as guerras, as desigualdades sociais, etc. Por fim, o protagonista consegue conversar com um “filósofo” desse planeta, e ambos acabam se fundindo numa massa incorpórea e saem explorando o resto do Universo.\nO protagonista segue encontrando milhares de espécies: algumas se destruíram em guerras inúteis, outras se perderam por fenômenos naturais (supernovas, meteoros, fim da atmosfera). Suas formas são as mais variadas: simbioses entre pseudo-caranguejos e pseudo-golfinhos, “homens”-árvores, enxames de “abelhas” pensantes, hominídeos pequenos, caracois que nadavam por aí feito barcos, etc. Algumas conseguiram atingir um nível avançado através da inteligência e consciência coletiva feita por telepatia. Assim, os planetas se tornavam “um único ser consciente”, e essa consciência se espalhava para outros sistemas conforme a espécie avançava na exploração espacial.\n\nThere was a moment, late in this early phase of our pilgrimage, when, thinking and feeling in unison, we said to one another, “If the Star Maker is Love, we know that this must be right. But if he is not, if he is some other, some inhuman spirit, this must be right. And if he is nothing, if the stars and all else are not his creatures but self-subsistent, and if the adored spirit is but an exquisite creature of our minds, then this must be right, this and no other possibility. For we cannot know whether the highest place for love is on the throne or on the cross. We cannot know what spirit rules, for on the throne sits darkness. We know, we have seen, that in the waste of stars love is indeed crucified; and rightly, for its own proving, and for the throne’s glory. Love and all that is humane we cherish in our hearts. Yet also we salute the throne and the darkness upon the throne. Whether it be Love or not Love, our hearts praise it, out-soaring reason.”\n\n\n\n\n\n\nO livro acompanha o protagonista em sua jornada por fundir-se a mais inteligências, a ascenção e queda de espécies, a tentativa de Utopia galática, a descoberta de que até as nebulosas são seres “vivos”.\nNo clímax do livro, por uma fração minúscula de segundo, ele aparece: o criador de estrelas. O protagonista enxerga um clarão consumir o Universo inteiro, como se de repente todos os átomos do universo explodissem em luzes.\n\nIt seemed to me that the Star, my Maker, must surely stoop to meet me and raise me and enfold me in his radiance. For it seemed to me that I, the spirit of so many worlds, the flower of so many ages, was the Church Cosmical, fit at last to be the bride of God. But instead I was blinded and seared and struck down by terrible light.\n\n\nI saw that the virtue of the creature was to love and to worship, but the virtue of the creator was to create, and to be the infinite, the unrealizable and incomprehensible goal of worshipping creatures.\n\nEle enxerga como num filme rápido a morte térmica do Universo, quando o último ser vivo escondido no interior frio de um planeta se apaga pra sempre; enxerga o próprio fim de sua existência boiante num universo escuro, arrastado por um sono eterno.\nEle enxerga também o Universo como se fosse visto de fora, do ponto de vista do criador, do Starmaker. Percebe que existem milhares de universos, e que eles são como brinquedos nas mãos de um ser infinitamente poderoso. O criador-de-estrelas cria universos para explorar seus próprios poderes: o primeiro universo só possuía uma dimensão, e seus seres eram como ondas sonoras; depois disso, existiu um universo bidimensional; depois, o nosso universo usual com tempo e espaço; depois, um universo com várias dimensões espaciais e 2 dimensões temporais; e assim o criador experimentava com a Matéria até obter um universo tão complexo e perfeito que o faria dar-se por satisfeito. O Criador era como uma criança que descobria a si mesma através de suas obras.\n\nEternally, so my dream declared to me, the Star Maker is perfect and absolute; yet in the beginning of the time proper to his creative mode he was an infant deity, restless, eager, mighty, but without clear will. He was equipped with all creative power. He could make universes with all kinds of physical and mental attributes. He was limited only by logic. Thus he could ordain the most surprising natural laws, but he could not, for instance, make twice two equal five. In his early phase he was limited also by his immaturity. He was still in the trance of infancy. Though the unconscious source of his consciously exploring and creating mentality was none other than his own eternal essence, consciously he was at first but the vague blind hunger of creativity.\n\nEm alguns dos universos, o criador intervia dividindo-se em 2: um espírito de destruição e o outro de salvação. Em outros, ele alterava as leis da física quando lhe aprouvia. Na maioria dos universos, porém, ele apenas assistia impassível, além do bem e do mal.\n\nWhen he had given the last touches to all the cosmical ages from the supreme moment back to the initial explosion and on to the final death, the Star Maker contemplated his work. And he saw that it was good.\n\nApós ser inundado pelas sensações do último e perfeito universo feito pelo criador, o protagonista percebe que não consegue mais compreender as coisas; o entendimento lhe abandona, e depois de alguns instantes ele acorda na Terra, no morro onde havia ido passear.\nSem entender porra nenhuma."
  },
  {
    "objectID": "posts/felicidade-imaginada/felicidade-imaginada.html",
    "href": "posts/felicidade-imaginada/felicidade-imaginada.html",
    "title": "Sobre a felicidade presente e a felicidade futura",
    "section": "",
    "text": "A felicidade presente é sempre real, enquanto que a felicidade futura é uma aposta arriscada que poucas vezes cumpre as expectativas. Imagem tirada do excelente Extra Fabulous Comics.\n\n\n“Cândido, ou O Otimismo”, é um dos livros mais famosos da literatura universal. Neste conto filosófico, Voltaire narra com sua ironia peculiar as aventuras do ingênuo Cândido, que nasceu num palácio e se apaixonou pela bela Cunegundes. Lá também vivia o sábio Pangloss, que afirmava “estar demonstrado” que esse é o melhor dos mundos possíveis (ridicularizando Leibniz, o mesmo Leibniz do cálculo diferencial). Quando descobrem o romance de Cândido e Cunegundes, este é expulso do palácio e passa passa por várias aventuras e desgraças tentando reencontrar sua amada: é recrutado por búlgaros, sobrevive ao terremoto de Lisboa de 1755, vê Pangloss ser enforcado pela inquisição, foge pra América onde sem querer enfia uma espada no irmão de Cunegundes, é roubado, levado como escravo, mas por fim consegue reencontrar sua amada e casa-se com ela em Constantinopla onde vivem na pobreza.\nA última cena desse conto poderia ser um “e viveram felizes para sempre”, mas não é. Nela vemos um Cândido abatido, como que “morto por dentro”; Pangloss (que ainda estava vivo e vivendo com eles!) lhe diz:\n\n— Todos os acontecimentos — dizia às vezes Pangloss a Cândido — estão devidamente encadeados no melhor dos mundos possíveis; pois, afinal, se não tivesses sido expulso de um lindo castelo, a pontapés no traseiro, por amor da senhorita Cunegundes, se a Inquisição não te houvesse apanhado, se não tivesses percorrido a América a pé, se não tivesses mergulhado a espada no barão, se não tivesses perdido todos os teus carneiros da boa terra do Eldorado, não estarias aqui agora comendo doce de cidra e pistache.\n\nAo que Cândido lhe responde, finalizando a história:\n\n— Tudo isso está muito bem dito — respondeu Cândido, — mas devemos cultivar nosso jardim.\n\nImagino o pobre Cândido trabalhando à exaustão em seu jardim como um meio de esquecer a vida e apenas sobreviver, após tantos anos imaginando o quanto seria feliz ao reencontrar sua amada, que já não estava bela como antes e nem era tão amável quanto ele imaginava. Em sua última frase, Cândido mostra que as “vãs filosofias” não lhe interessam, e que é preciso trabalhar para viver. Como o Sísifo de Camus, é preciso imaginar Cândido feliz enquanto carregava sua pedra, isto é, enquanto fazia de tudo para reencontrar Cunegundes. Mas depois do encontro, o que lhe restou? A felicidade imaginada lhe pregou uma peça; o pêndulo de Schopenhauer é implacável.\n\nVoltaire deixa Cândido sozinho em seu jardim, com o peso da própria existência pairando em sua mente, num “zoom out” cruel. Não sabemos seu fim, nem o que se passa em sua cabeça: o retrato do Otimismo que precisou confrontar a realidade de um mundo “feito para nos dar raiva”, como dizia o cínico Martinho.\n\n\n\nCapa cabulosa da editora 34."
  },
  {
    "objectID": "posts/tchekhov-solidao/tchekov-solidao.html",
    "href": "posts/tchekhov-solidao/tchekov-solidao.html",
    "title": "Sobre Tchekhov e as pequenas tragédias despercebidas",
    "section": "",
    "text": "Muitos contos de Tchekhov, o mestre da prosa curta, são como fotografias da alma humana. Através de situações comuns, de personagens humanos (sem heróis nem vilões), podemos ver recortes de vidas e o mundo subjetivo de personagens os mais diversos. Em poucas páginas tem-se ali, cristalizada, uma sensação que dificilmente conseguiria ser descrita de outro modo. Costumo pensar neles como um catálogo (ou paleta-de-cores) das situações humanas.\n\nEm “Angústia”, Tchekhov explora a solidão dos desprezados, a necessidade do Homem de ter uma palavra de compreensão, de poder contar uma tragédia pessoal e sentir um olhar de pena. Aos preguiçosos ou apressados, faço um resumo da história abaixo. Deixo entre aspas os trechos originais da tradução do Boris Schnaiderman.\nIona, um cocheiro pobre cujo filho morrera recentemente, não tinha “a quem confiar sua tristeza”. Acompanhamos Iona e seu cavalinho numa noite escura, próximos a uma praça, esperando passageiros.\nApós muito tempo imóvel sob a neve, surge um militar solicitando uma viagem curta. Com o coração pesado, Iona tenta contar-lhe:\n“- Pois é, meu senhor, assim é… perdi um filho esta semana…”\nO passageiro não lhe dá atenção. Na rua as pessoas trombam na carruagem de Iona e o xingam; o militar pede para Iona ir mais rápido. Chegando ao destino, Iona fica novamente parado em sua boleia, esperando, vendo as horas passar sob a neve, imóvel…\nPor fim, um grupo de bêbados (dentre eles um corcunda) sai de um bar e solicita uma viagem a Iona, pagando um valor muito abaixo do esperado. Ele aceita, pois é melhor do que nada. Os bêbados se xingam, brigam, caçoam do chapeu do cocheiro, dão-lhe tapas para ir mais rápido. Iona, em dado momento, tenta lhes contar:\n“– Esta semana… assim, perdi meu filho!\n– Todos vamos morrer. – suspira o corcunda, enxugando os lábios, após um acesso de tosse. – Bem, bate nele, bate nele! Minha gente, decididamente, não posso continuar andando assim! Esta corrida não acaba mais?\nE Iona volta-se, para contar como lhe morreu o filho, mas, nesse momento, o corcunda solta um suspiro de alívio e declara que, graças a Deus, chegaram ao destino.\nIona está novamente só e, de novo, o silêncio desce sobre ele… A angústia que amainara por algum tempo torna a aparecer, inflando-lhe o peito com redobrada força. Os olhos de Iona correm, inquietos e sofredores, pela multidão que se agita de ambos os lados da rua: não haverá, entre esses milhares de pessoas, uma ao menos que possa ouvi-lo? Mas a multidão corre, sem reparar nele, nem na sua angústia… Uma angústia imensa, que não conhece fronteiras. Dá a impressão de que, se o peito de Iona estourasse e dele fluísse para fora aquela angústia, daria para inundar o mundo e, no entanto, não se pode vê-la. Conseguiu caber numa casca tão insignificante, que não se pode percebê-la mesmo de dia, com muita luz…”\nIona resolve ir para casa. Seu cavalinho trota ligeiro.\nUma hora e meia depois, numa casa que dividia com outros cocheiros, Iona está sentado ao lado do fogão sujo. Há gente roncando por todos os lados; o ar é abafado, sufocante… Um cocheiro acorda para beber água, Iona tenta puxar conversa mas o homem logo volta a dormir.\n“É preciso contar como o filho adoeceu, como padeceu, o que disse antes de morrer e como morreu… É preciso descrever o enterro e a ida ao hospital, para buscar a roupa do defunto. Na aldeia, ficou a filha Aníssia… É preciso falar sobre ela também… De quantas coisas mais poderia falar agora? O ouvinte deve soltar exclamações, suspirar, lamentar… E é ainda melhor falar com mulheres. São umas bobas, mas desandam a chorar depois de duas palavras.”\nIona vai ao encontro de seu cavalinho no estábulo, e “pensa sobre a aveia, o feno, o tempo… Estando sozinho, não pode pensar no filho… Pode-se falar sobre ele com alguém, mas pensar nele sozinho, desenhar mentalmente sua imagem, dá um medo insuportável…\n– Está mastigando? – pergunta Iona ao cavalo, vendo seus olhos brilhantes. – Ora, mastiga, mastiga… Se não ganhamos para a aveia, vamos comer feno… Sim… Já estou velho para trabalhar de cocheiro… O filho é que devia trabalhar, não eu… Era um cocheiro de verdade… Só faltou viver mais…\nIona permanece algum tempo em silêncio e prossegue:\n– Assim é, irmão, minha egüinha… Não existe mais Kuzmá Iônitch… Foi-se para o outro mundo… Morreu assim, por nada… Agora, vamos dizer, você tem um potrinho, que é teu filho… E, de repente, vamos dizer, esse mesmo potrinho vai para o outro mundo… Dá pena, não é verdade?\nO cavalinho vai mastigando, escuta e sopra na mão de seu amo… Iona anima-se e conta-lhe tudo…”\n\nTudo o que sabemos da história de Iona são fragmentos que ele tenta contar aos outros e alguns poucos pensamentos que ele tem.\nTchekhov não nos narra a doença do filho de Iona, as angústias do pai, as idas ao hospital, a notícia da morte, o enterro, o luto… sabemos apenas que essas coisas aconteceram e que Iona queria contá-las a alguém, queria que alguém o ouvisse como a um irmão. Vemos Iona e seu cavalinho sob a neve, esperando passageiros; vemos Iona tentando esvaziar o coração e sendo desprezado, sentimos a indeferença dos outros ante morte de seu filho, e o vemos seguindo solitário até chegar em casa… por fim, o único que o ouviu foi seu cavalo.\nIona até tenta fazer o cavalo entender melhor a situação (“Agora, vamos dizer, você tem um potrinho, que é teu filho… E, de repente, vamos dizer, esse mesmo potrinho vai para o outro mundo… Dá pena, não é verdade?”), e podemos imaginar a cena: um senhorzinho conversando com seu cavalo, no escuro, sob a neve, ao lado da casinha mal iluminada. Um homem sozinho no mundo, cujo único ouvinte sobre a tristeza que lhe devorava era o próprio instrumento de trabalho. O conto acaba ali: Iona em seu monólogo. Não sabemos o que acontece depois. Tchekhov larga a pena quando percebe que acabou seu retrato claro sobre a angústia humana, que passou despercebida por quem viu o cocheiro Iona naquela noite."
  },
  {
    "objectID": "posts/eletronic-bard/eletronic-bard.html",
    "href": "posts/eletronic-bard/eletronic-bard.html",
    "title": "A era das máquinas artistas e o bardo eletrônico de Lem",
    "section": "",
    "text": "Ou: como Stanislaw Lem fantasiou uma versão exagerada do chatGPT na década de 60.\n“Trurl, o famoso construtor, um dia resolveu criar uma máquina que escrevia poesia para provar a seu amigo Klapaucius quem era o melhor construtor do universo.”\nMais ou menos assim começa o conto “The eletronic Bard” the Stanislaw Lem, escrito na década de 60. Publicado no livro “Cyberiads”, inaugurou um gênero literário bizarro que mistura ficção científica e contos de fada medievais com a ironia de Voltaire e a prosa macarrônica de Rabelais. O livro narra as aventuras de Trurl e Klapaucius, dois robôs inventores capazes de criar praticamente qualquer coisa (como a máquina que materializava tudo que começava com “n”, ou uma miniatura de um reino que se revoltou contra o rei, ou o robô gigante que dizia que 2+2 é 7 e tentou matar Trurl, ou a máquina que imprimia todas as verdades do universo). Ambos tentam cumprir pedidos quase impossíveis de reis de toda a galáxia em troca de ouro, e quase sempre acabam arrumando problema e tendo que fugir.\nGosto tanto dessa história que vou recontar ela do meu jeito abaixo, entre aspas:\n“Trurl juntou 820 toneladas de livros sobre cibernética e 1200 toneladas de livros de poesia e se pôs a ler. Quando cansava de uma equação, lia um verso1. Percebeu então que a parte mais difícil da máquina seria o programa em si, e não o hardware. O ‘programa’ na cabeça de um poeta era, afinal, escrito pela civilização do poeta; e esta, por sua vez, era fruto das civilizações anteriores. Trurl então percebeu que seria mais fácil criar um universo virtual (desde o big bang!) e deixar naturalmente o poeta surgir de uma versão cibernética da Terra.”\nAqui há um paralelo interessante com os large language models (LLM) atuais, como o ChatGPT e o Google Bard2: em vez de ensinar gramática e rimas e poesia a um algoritmo (isto é: em vez de passar todas as instruções uma a uma, como se ensinaria um robô obediente), hoje monta-se uma arquitetura de rede neural capaz de aprender a interpretar textos, e então alimenta-se essa rede neural com bilhões de textos até ela aprender sozinha a falar uma linguagem e responder a humanos. Parecido com o modo como os bebês aprendem a falar!\nNo fim da década de 50 as redes neurais ficaram famosas por prometerem imitar o aprendizado do cérebro humano. Criou-se muita expectativa sobre robôs que pensavam como humanos e andariam por aí resolvendo tarefas difíceis. Porém, a falta de poder computacional da época e alguns projetos fracassados levaram ao “inverno da IA” que durou várias décadas. Por isso talvez para Lem parecia impossível um robô poeta, objeto de um conto rocambólico do Cyberiads.\nA história segue:\n“Após os preparativos, a simulação do universo começou. Trurl foi adicionando mais e mais processadores ao computador, e teve que reinciar a simulação duas vezes: uma porque um fusível queimado fez Abel matar Caim, e na outra porque algo errado aconteceu na árvore evolutiva e em vez de termos os grandes macacos (great apes) surgiram cortinas cinzas (gray drapes). Passou-se a Antiguidade, a Idade Média, as reformas, e as revoluções. Ao chegar no século 20, com as grandes guerras, Trurl teve que jogar água na máquina que não parava de esquentar e vibrar. Civilizações surgiram e se foram a cada 25 mil anos, e Trurl precisava adicionar mais e mais fitas para salvar todos os dados. Tudo isso para obter um poeta!\nApós milhões de anos na simulação, Trurl escolheu o melhor poeta de todos. Ajustando o sensor de emotividade, adicionando um campo semântico e uma alavanca filosófica, tudo o que o poeta disse foi “Eu tinha um sapo”. Trurl continuou mexendo na máquina, adicionando filtros de clichê, um alternador de rimas, retirando alguns circuitos lógicos e por fim colocando um narcistor egocentripetal3 até que ela finalmente produziu um poema razoável.\nExtasiado, Trurl chamou Klapaucius para ver sua criação. Klapaucius estava cético e a princípio achou que os poemas do bardo eletrônico já estavam escritos num banco de dados, e que o bardo era apenas um recitador de coisas prontas. Para testá-lo, pediu que ele fizesse ‘um poema de amor, lírico, pastoral, expresso na linguagem da matemática pura; com bastante álgebra tensorial, um pouco de topologia e talvez cálculo avançado.’ Trurl ficou indignado e com medo de que o bardo quebrasse, mas ele começou um enorme poema assim4:\nKlapaucius inventou uma desculpa qualquer e foi embora, visivelmente abalado.\nPouco tempo se passou até que notícias sobre o bardo chegassem nos poetas genuínos - isto é, ordinários. Ofendidos, resolveram ignorar a existência da máquina. Mas alguns curiosos foram visitar o bardo, que os recebeu educadamente com suas pilhas de poemas. Esses poetas eram vanguardistas, e o bardo escrevia apenas no estilo clássico. Os poetas caçoaram dele e foram embora. A máquina, porém, se auto-programava, e além disso tinha um aplificador-de-ambição com circuitos de busca-pela-glória. Rapidamente notou-se uma mudança: o bardo começou a fazer poemas tão intrincados e carregados de significados que se tornaram praticamente incompreensíveis.\nOs poetas continuavam indo até a casa de Trurl encontrar o bardo, mas mal começavam um poema e o bardo, imitando o estilo do poeta, lançava torrentes de rimas para humilhar o pobre visitante. Alguns poetas cometeram suicídio, outros organizaram protestos exigindo o desligamento da máquina, mas além deles ninguém parecia se importar: o bardo, escrevendo sob centenas de pseudônimos, tinha um poema para cada ocasião, do tamanho desejado, e de tal qualidade que qualquer revista seria comprada apenas pelos versos. Todos conheciam os poemas do bardo eletrônico de Trurl e suas rimas deliciosas; elas estavam em todos os jornais e revistas. Alguns até desmaiavam de prazer ao ler seus poemas.”\nAqui outro paralelo curiosíssimo com a atualidade: artistas protestando contra a arte gerada por IAs, enquanto empresas usam essas tecnologias para diminuir custos. Para um dono de empresa, é mais barato pagar o ChatGPT4 do que um redator, ou gerar imagens pelo Dall-E 3 do que pagar um ilustrador. Além dos próprios artistas, são poucos os que se incomodam a ponto de ir contra as máquinas artistas.\n“Trurl começou a ter problemas por causa de sua invenção. Os poetas clássicos não lhe incomodavam, pois eram quase todos velhos e inofensivos; se limitavam a jogar pedras na sua casa ou esfregar susbtâncias mal-cheirosas em suas paredes. Os mais novos, porém, já eram piores: um deles era tão bom com versos quanto na porrada e fez Trurl parar no hospital. Ainda internado, os protestos continuavam. Mais e mais poetas levavam maletas com rifles em vez de poemas para tentar destruir o bardo: vão, pois as balas ricocheteavam em seu enorme exterior metálico. Ao sair do hospital, Trurl decidiu então desligar o bardo para sempre para poder ter paz.\nMas, ao aproximar-se mancando da máquina, ela percebeu a intenção de Trurl e recitou um pedido de misericórdia tão eloquente e apaixonado que o famoso construtor saiu dali em lágrimas. No mês seguinte, ao receber a conta de energia elétrica, Trurl quase caiu de sua cadeira. Durante a noite, desligou o bardo da tomada, desmontou-o, colocou-o em sua nave e levou-o até um asteroide, onde o montou junto de uma pilha de material radiativo para servir de energia.\nA história não acaba aí. O bardo, sem ter como publicar seus poemas, resolveu transmiti-los em todas as frequências de onda, fazendo com que os passageiros das naves que por ali passavam entrassem num estado de estupefação e sofressem ataques de êxtase. O Comando das Frotas Cósmicas enviou um time de técnicos para resolver o problema, mas o bardo improvisou diversas baladas que os fizeram chorar. Resolveram então enviar outro time de técnicos, dessa vez surdos, mas a máquina fez uso de pantomimas e também eles ficaram maravilhados. Após isso, começou-se a aventar a possibilidade de uma bomba atômica no asteroide, mas um rei de uma estrela vizinha apareceu e levou a máquina embora para seu reino.\nFinalmente Trurl pôde voltar a aparecer em público.\nAlgumas supernovas começaram a explodir de maneira estranha no horizonte, e havia rumores de que isso estava relacionado com poesia. De acordo com um relato, o rei que levou o bardo, movido por um estranho capricho, havia conectado o bardo a uma constelação de supergigantes, transformando cada linha de verso em uma estupenda proeminência solar: assim, o maior poeta do universo era capaz de transmitir suas criações termonucleares para todo o espaço. Mesmo que esse relato fosse verdadeiro, era distante demais para incomodar Trurl, que jurou nunca mais fazer um modelo cibernético da Musa.”\nO que acontecerá quando as máquinas quiserem continuar produzindo arte e ninguém mais for consumi-las? Será que elas aprenderão a apreciar a arte uma das outras como nós fazemos? As máquinas artistas de hoje estão quase a ponto de superar o brilhante bardo eletrônico do Lem, e é difícil imaginar o que virá depois…"
  },
  {
    "objectID": "posts/eletronic-bard/eletronic-bard.html#footnotes",
    "href": "posts/eletronic-bard/eletronic-bard.html#footnotes",
    "title": "A era das máquinas artistas e o bardo eletrônico de Lem",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nera assim que eu estudava Análise Funcional no doutorado↩︎\nque não tem relação com o Eletronic Bard do Lem, e sim com Shakespeare↩︎\nLem é um mestre na arte de inventar nomes ridículos que parecem de verdade↩︎\ndeixei o poema em inglês como na versão que li; o original é em polonês, e vou evitar aqui a lambança de traduzir uma tradução↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Nothing to declare"
  },
  {
    "objectID": "pdf_docs/symbolic regression/post.html#what-is-it",
    "href": "pdf_docs/symbolic regression/post.html#what-is-it",
    "title": "Symbolic Regression in Julia",
    "section": "",
    "text": "A linear regression finds the line that is “closest” to a dataset. In a similar maner, a symbolic regression is an algorithm that find a combination of symbols that minimizes the mean square error of a given dataset. These symbols are unary and binary operators like the + symbol or a function like \\(cos\\) and \\(1/x\\)."
  },
  {
    "objectID": "pdf_docs/symbolic regression/post.html#examples",
    "href": "pdf_docs/symbolic regression/post.html#examples",
    "title": "Symbolic Regression in Julia",
    "section": "Examples",
    "text": "Examples\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nb\nc"
  },
  {
    "objectID": "pdf_docs/symbolic regression/post.html#remarks",
    "href": "pdf_docs/symbolic regression/post.html#remarks",
    "title": "Symbolic Regression in Julia",
    "section": "Remarks",
    "text": "Remarks"
  },
  {
    "objectID": "pdf_docs/symbolic regression/post.html#example-1",
    "href": "pdf_docs/symbolic regression/post.html#example-1",
    "title": "Symbolic Regression in Julia",
    "section": "Example 1",
    "text": "Example 1\nLet’s try to approximate the function \\(f(x) = - x^2 + 1\\) using the symbols and \\(+, -, *\\) combined with the variable \\(x\\).\n\nusing SymbolicRegression, MLJ, SymbolicUtils\nusing Plots\n\nx = [-3:0.1:3;]\ny = @. - x^2 + 1;\n\nscatter(x, y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst we define a model\n\nmodel = SRRegressor(\n    binary_operators=[+, -, *],    \n    niterations=50\n);\n\nAnd then fit it to our dataset\n\nX = reshape(x, (length(x), 1))\n\nmach = machine(model, X, y)\nfit!(mach)\n\nWe can see a report about the results:\n\nr = report(mach);\n\nr\n\n(best_idx = 2,\n equations = DynamicExpressions.EquationModule.Node{Float64}[-2.099999999997616, (1.0 - (x₁ * x₁))],\n equation_strings = [\"-2.099999999997616\", \"(1.0 - (x₁ * x₁))\"],\n losses = [7.681799999999998, 0.0],\n complexities = [1, 5],\n scores = [36.04365338911715, 9.010913347279288],)\n\n\nThis report contains the losses\n\nr.losses\n\n2-element Vector{Float64}:\n 7.681799999999998\n 0.0\n\n\nthe equations\n\nr.equations\n\n2-element Vector{DynamicExpressions.EquationModule.Node{Float64}}:\n -2.099999999997616\n (1.0 - (x₁ * x₁))\n\n\nand the best one of the functions found (ie. the one with the least loss):\n\nnode_to_symbolic(r.equations[r.best_idx], model)\n\n1.0 - (x1 * x1)\n\n\nHere, we can read \\(x_1\\) as \\(x\\), because we only have one variable.\nNotice that this expression simplifies to our original \\(f\\)."
  },
  {
    "objectID": "pdf_docs/symbolic regression/post.html",
    "href": "pdf_docs/symbolic regression/post.html",
    "title": "Symbolic Regression in Julia",
    "section": "",
    "text": "A linear regression finds the line that is “closest” to a dataset. In a similar maner, a symbolic regression is an algorithm that find a combination of symbols that minimizes the mean square error of a given dataset. These symbols are unary and binary operators like the + symbol or a function like \\(cos\\) and \\(1/x\\)."
  },
  {
    "objectID": "pdf_docs/symbolic regression/post.html#example-2",
    "href": "pdf_docs/symbolic regression/post.html#example-2",
    "title": "Symbolic Regression in Julia",
    "section": "Example 2",
    "text": "Example 2\nNow let’s get a more interesting example. Take \\(f(x) = x^2 - cos(x)^2 - 2x\\):\n\ny = @. x^2 + 2cos(x)^2 \n\nscatter(x, y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe again create a model and fit it, but now we allow more operations: besides the earlier binary functions, we also have the unary cos function:\n\nmodel = SRRegressor(\n    binary_operators = [+, -, *],    \n    unary_operators = [cos],\n    niterations=50\n);\n\nmach = machine(model, X, y)\nfit!(mach)\n\nand see the best equation:\n\nr = report(mach)\nnode_to_symbolic(r.equations[r.best_idx], model)\n\n(((x1 * (x1 * 1.0)) + (cos(x1 + x1) + 1.6907874758301153)) + -1.0530981189123707) - -0.36231064308225547\n\n\nSo, we got\n\\[\nx * x + cos(x + x) + 1 = x^2 + cos(2x) + 1\n\\]\nSince \\(cos(2x) + 1 = 2cos^2(x)\\), we retrieve the original function."
  },
  {
    "objectID": "pdf_docs/symbolic regression/post.html#example-3",
    "href": "pdf_docs/symbolic regression/post.html#example-3",
    "title": "Symbolic Regression in Julia",
    "section": "Example 3",
    "text": "Example 3\nEven after adding some noise to the original dataset, the symbolic regression still can find a very good approximation:\nTake \\(f(x) = 0.3 * x^3 - x^2 + 2cos(x) + \\epsilon(x)\\) where \\(\\epsilon(x)\\) is a random uniform error (varying in \\([0, 1]\\)) like this:\n\nx = [-5:0.1:5;]\nX = reshape(x, (length(x), 1))\nerrors = rand(length(x))\ny = @. 0.3*x^3 - x^2 + 2cos(x) + errors\n\nscatter(x, y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel = SRRegressor(\n    binary_operators = [+, -, *],    \n    unary_operators = [cos],\n    niterations=60\n);\n\nmach = machine(model, X, y)\nfit!(mach)\n\nand see the best equation:\n\nr = report(mach)\nnode_to_symbolic(r.equations[r.best_idx], model)\n\n(((((x1 + -3.3193248331583898) * x1) * 0.29952780043120636) * x1) + (cos(x1) * 1.8373574799964867)) + 0.49811385096465227\n\n\nWe can plot the prediction and the original dataset to compare them:\n\ny_pred = predict(mach, X)\n \nscatter(x, y);\nscatter!(x, y_pred, color = \"red\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNot bad at all!\nYou can see more about this package in this link. If you have enough courage, read the original paper on arxiv!"
  },
  {
    "objectID": "posts/symbolic regression/post.html",
    "href": "posts/symbolic regression/post.html",
    "title": "Symbolic Regression in Julia",
    "section": "",
    "text": "A linear regression finds the line that is “closest” to a dataset. In a similar maner, a symbolic regression is an algorithm that find a combination of symbols that minimizes the mean square error of a given dataset. These symbols are unary and binary operators like the + symbol or a function like \\(cos\\) and \\(1/x\\)."
  },
  {
    "objectID": "posts/symbolic regression/post.html#what-is-it",
    "href": "posts/symbolic regression/post.html#what-is-it",
    "title": "Symbolic Regression in Julia",
    "section": "What is it?",
    "text": "What is it?\nA linear regression finds the line that is “closest” to a dataset. In a similar maner, a symbolic regression is an algorithm that find a combination of symbols that minimizes the mean square error of a given dataset. These symbols are unary and binary operators like the + symbol or a function like \\(cos\\) and \\(1/x\\)."
  },
  {
    "objectID": "posts/symbolic regression/post.html#example-1",
    "href": "posts/symbolic regression/post.html#example-1",
    "title": "Symbolic Regression in Julia",
    "section": "Example 1",
    "text": "Example 1\nLet’s try to approximate the function \\(f(x) = - x^2 + 1\\) using the symbols and \\(+, -, *\\) combined with the variable \\(x\\).\n\nusing SymbolicRegression, MLJ, SymbolicUtils\nusing Plots\n\nx = [-3:0.1:3;]\ny = @. - x^2 + 1;\n\nscatter(x, y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst we define a model\n\nmodel = SRRegressor(\n    binary_operators=[+, -, *],    \n    niterations=50\n);\n\nAnd then fit it to our dataset\n\nX = reshape(x, (length(x), 1))\n\nmach = machine(model, X, y)\nfit!(mach)\n\nWe can see a report about the results:\n\nr = report(mach);\n\nr\n\n(best_idx = 2,\n equations = DynamicExpressions.EquationModule.Node{Float64}[-2.1000000000160663, (1.0 - (x₁ * x₁))],\n equation_strings = [\"-2.1000000000160663\", \"(1.0 - (x₁ * x₁))\"],\n losses = [7.681799999999998, 0.0],\n complexities = [1, 5],\n scores = [36.04365338911715, 9.010913347279288],)\n\n\nThis report contains the losses\n\nr.losses\n\n2-element Vector{Float64}:\n 7.681799999999998\n 0.0\n\n\nthe equations\n\nr.equations\n\n2-element Vector{DynamicExpressions.EquationModule.Node{Float64}}:\n -2.1000000000160663\n (1.0 - (x₁ * x₁))\n\n\nand the best one of the functions found (ie. the one with the least loss):\n\nnode_to_symbolic(r.equations[r.best_idx], model)\n\n1.0 - (x1 * x1)\n\n\nHere, we can read \\(x_1\\) as \\(x\\), because we only have one variable.\nNotice that this expression simplifies to our original \\(f\\)."
  },
  {
    "objectID": "posts/symbolic regression/post.html#example-2",
    "href": "posts/symbolic regression/post.html#example-2",
    "title": "Symbolic Regression in Julia",
    "section": "Example 2",
    "text": "Example 2\nNow let’s get a more interesting example. Take \\(f(x) = x^2 + 2cos(x)^2\\):\n\ny = @. x^2 + 2cos(x)^2 \n\nscatter(x, y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe again create a model and fit it, but now we allow more operations: besides the earlier binary functions, we also have the unary cos function:\n\nmodel = SRRegressor(\n    binary_operators = [+, -, *],    \n    unary_operators = [cos],\n    niterations=50\n);\n\nmach = machine(model, X, y)\nfit!(mach)\n\nand see the best equation:\n\nr = report(mach)\nnode_to_symbolic(r.equations[r.best_idx], model)\n\ncos(x1 + x1) + (cos(x1 - x1) + (x1 * x1))\n\n\nSo, we got\n\\[\ncos(x - x) + x * x + cos(x + x) = 1 + x^2 + cos(2x)\n\\]\nSince \\(1 + cos(2x) = 2cos^2(x)\\), we retrieve the original function."
  },
  {
    "objectID": "posts/symbolic regression/post.html#example-3",
    "href": "posts/symbolic regression/post.html#example-3",
    "title": "Symbolic Regression in Julia",
    "section": "Example 3",
    "text": "Example 3\nEven after adding some noise to the original dataset, the symbolic regression still can find a very good approximation:\nTake \\(f(x) = 0.3 * x^3 - x^2 + 2cos(x) + \\epsilon(x)\\) where \\(\\epsilon(x)\\) is a random uniform error (varying in \\([0, 1]\\)) like this:\n\nx = [-5:0.1:5;]\nX = reshape(x, (length(x), 1))\nerrors = rand(length(x))\ny = @. 0.3*x^3 - x^2 + 2cos(x) + errors\n\nscatter(x, y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel = SRRegressor(\n    binary_operators = [+, -, *],    \n    unary_operators = [cos],\n    niterations=60\n);\n\nmach = machine(model, X, y)\nfit!(mach)\n\nand see the best equation:\n\nr = report(mach)\nnode_to_symbolic(r.equations[r.best_idx], model)\n\n(((x1 * (3.3255216468533675 - x1)) * (x1 * -0.30020630560881595)) + (cos(x1) * 1.9744557563006342)) - -0.4984467307767236\n\n\nWe can plot the prediction and the original dataset to compare them:\n\ny_pred = predict(mach, X)\n \nscatter(x, y);\nscatter!(x, y_pred, color = \"red\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNot bad at all!\nYou can see more about this package in this link. If you have enough courage, read the original paper on arxiv!"
  },
  {
    "objectID": "livros.html",
    "href": "livros.html",
    "title": "Livros",
    "section": "",
    "text": "Fragmentos literários e pensamentos baratos.\n\n\n\n\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nSobre a felicidade presente e a felicidade futura\n\n\n\n\n\n\n\n\nFeb 26, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n“História do futuro” e os limites da imaginação\n\n\n\n\n\n\n\n\nJan 28, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nSobre Tchekhov e as pequenas tragédias despercebidas\n\n\n\n\n\n\n\n\nJan 23, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nA era das máquinas artistas e o bardo eletrônico de Lem\n\n\n\n\n\n\n\n\nJan 16, 2024\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "ds.html",
    "href": "ds.html",
    "title": "Data Science",
    "section": "",
    "text": "Mostly about cool things I found in Julia.\n\n\n\n\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nJulia for R users\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSymbolic Regression in Julia\n\n\n\n\n\n\n\n\nMar 14, 2024\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "About me",
    "section": "",
    "text": "vituri.vituri@gmail.com / https://github.com/vituri1"
  },
  {
    "objectID": "cv.html#education",
    "href": "cv.html#education",
    "title": "About me",
    "section": "EDUCATION",
    "text": "EDUCATION\nDoctor of Philosophy – Topological Data Analysis  Universidade Estadual Paulista (Unesp) / Ohio State University (OSU) 2016 — 2020\n\nI spent six months at the Ohio State University under Facundo Mémoli supervision.\nWe generalized the Vietoris-Rips and Cech constructions using “motifs”: families of graphs that can be attached to metric spaces (more generally, networks) and generate simplicial complexes. As a corollary, we obtain several clustering methods on graphs.\nThe resulting work is “Motivic constructions on graphs and networks with stability results” and can be found here.\n\nMaster Degree – Algebraic Topology  Universidade Estadual Paulista (Unesp) 2014 — 2015\n\nI studied a certain subgroup of the fundamental group, called “Gottlieb group”, and proved some results about its properties. The dissertation can be found here.\n\nBachelor in Mathematics  Universidade Estadual Paulista (Unesp) 2010 — 2013"
  },
  {
    "objectID": "cv.html#work-experience",
    "href": "cv.html#work-experience",
    "title": "About me",
    "section": "WORK EXPERIENCE",
    "text": "WORK EXPERIENCE\n\nHead of Intelligence\nArgus Solutions Jan 2020 – Jan 2025\nI founded the area of Data at Argus, and my role was crucial as the company went from a small-sized tech to a multinational. My team now has more than 12 people as diverse as developers, data scientists, engineers and mathematicians. I act as a manager, code reviewer, project manager, machine learning engineer, DevOps, R/Julia developer and database administrator. I can do a bit of everything.\n\nWe went from hundreds of Excel files to a MariaDB database on AWS. I designed the database, its indexes and applied some normal forms.\nI wrote dozens of R/Julia scripts to read and write data from several sources and created a pipeline of information that ran smoothly\nI automated the generation and mailing of thousands of daily/weekly reports using RMarkdown and Sendgrid, which previously was done by 3 people.\nI created several analytics dashboards using the shiny framework, in place of a former Tableau dashboard. I also developed the main platform used by the team to analyze photos/videos.\nWe created a machine learning model that predicts if a driver is going to sleep in the next hour, using an ensemble of models with tidymodels.\nI created a webserver in Julia using Oxygen.jl to read data from several APIs and write they in our databases. A previous version of this code was written in R and each iteration took almost 4 minutes; it was reduced to 5 seconds in Julia using some paralellism magic.\nI participated in the creation of many computer vision algorithms to detect cellphones, drowsiness, potholes and gestures using keras and YOLO.\nI interviewed and hired people, managed the team and developed the abilities we needed to finish our projects."
  },
  {
    "objectID": "cv.html#tools-and-skills",
    "href": "cv.html#tools-and-skills",
    "title": "About me",
    "section": "TOOLS AND SKILLS",
    "text": "TOOLS AND SKILLS\n\nR\n\ntidyverse: I use several of these packages everyday; I am “fluent” in dplyr, purrr, tidyr, stringr, tibble and many others. I prefer to use echarts4r instead of ggplot2. With dbplyr, I can translate many complicated transformations to SQL in a painless way.\nshiny: I explored a lot of the shiny ecosystem since 2018: from shinydashboard to the new bslib, using shinyWidgets and toastui. I can create dashboards, CRUDS, user interfaces, display photos/videos and maps. Async and parallelism are a bit painful but can be done with future and promises.\nI am also very familiar with igraph to manipulate graphs, leaflet to plot maps, httr2 to make gets and posts, plumber to create APIs, reticulate to interface Python.\nI can create packages, documentation and tests. Unfortunately, my best packages are private but a public example can be found here.\n\n\n\nJulia\nCoding in Julia is a joy and make R/Python look like unpolished old languages used by barbarians.\n\nI started learning Julia to write some Topological Data Analysis algorithms and the result was impressive, even with my initial poor skills.\nI am the owner of the JuliaTDA organization which aims to bring the Topological Data Analysis ecosystem to Julia. I wrote the Mapper and Ball Mapper algorithms in Julia and the documentation in Quarto, and later also wrote the ToMATo algorithm.\nBuilding JuliaTDA, I was able to get familiar with parallelism, code piracy, structs, multiple dispatch, profiling (memory allocations and algorithm efficiency) and plotting tools like Plots and Makie.\nThe book “Hands-On Design Patterns and Best Practices with Julia” is my bible, and I am rewriting all my previous code using what I learned there.\nSince I like the tidyverse so much, I am now part of the TidierOrg: a 100% Julia organization inspired by R data tools. I am the main contributor to TidierIteration.jl, a Julia version of R’s purrr.\nSince I like Quarto so much, I created a package that helps writing Julia documentation with it: QuartoDocBuilder. Its own documentation is written in Quarto!\n\n\n\nAWS\n\nI can create and manage EC2 instances, use S3 to storage and query data, create databases in RDS and create dashboards with metrics.\nI created a facial recognition system of unlabeled drivers using S3 and Rekognition.\nRecently I moved several R/Julia/Python scripts from EC2 to ECS services, providing a reproducible and isolated environment for each code. While doing this, I learned how to create images with Docker, building them with EC2 Image Builder and storing it all in ECR.\n\n\n\nPython\n\nI can read code and port it to another language when necessary; I never had the need to write pure-Python code, but can learn it easily if needed. Using R’s reticulate and Julia’s PythonCall.jl, I was able to use many Python packages elsewhere.\n\n\n\nPublishing\n\nI used a lot of RMarkdown to generate a wide range of dashboards, reports and analysis. Now I prefer to use Quarto because of its many cool features (sites, blogs and dashboards) and easiness to use with Julia.\nI am writing a book called Topological Data Analysis with Julia while I implement several TDA algorithms in JuliaTDA."
  },
  {
    "objectID": "cv.html#presentations-and-workshops",
    "href": "cv.html#presentations-and-workshops",
    "title": "About me",
    "section": "PRESENTATIONS AND WORKSHOPS",
    "text": "PRESENTATIONS AND WORKSHOPS\n\nTalk: Topology meets the real world: how geometry can help us analyse finite metric spaces (2023, at the Workshop of Algebraic Topology and Applications).\nWorkshop: Topological Data Analysis workshop (2024, at the XXIII Brazilian Topology Meeting)."
  },
  {
    "objectID": "posts-livros/future-history/future-history.html",
    "href": "posts-livros/future-history/future-history.html",
    "title": "“História do futuro” e os limites da imaginação",
    "section": "",
    "text": "Se o melhor jeito de prever o futuro é inventá-lo, Olaf Stapledon foi um dos maiores inventores da literatura.\nEm 1930, Stapledon publicou “Last and First men”, um livro de “história do futuro” que conta a trajetória da humanidade desde a primeira guerra mundial até sua extinção em Netuno, 2 bilhões de anos no futuro, após uma supernova destruir o sistema Solar. Stapledon descreve em detalhes cada uma das 18 espécies pós-humanas: como elas mudaram de aparência física e perderam a inteligência; como, milhões de anos depois, redescobriram a ciência, modificaram a si mesmos com engenharia genética, chegando até a criar uma nova espécie artificial. Porém não é sobre esse livro que falarei hoje.\n\n\n\nFicção científica e suas capas cabulosas\n\n\nEm 1937 Stapledon publica “Star maker”, cujo enredo muito mais ambiciosa faz “Last and first men” parecer um minúsculo continho: narrar a história inteira do Universo e dos seres vivos. O livro começa de maneira inusitada quando um homem casado vai dar um passeio à noite perto de sua casa pensando sobre o amor, o casamento, a união das almas, o sentido da vida, quando de repente vira um ser incorpóreo e começa a boiar no espaço, vendo a Terra se afastando rapidamente.\n\nBut now irrationally I was seized with a strange worship, not, surely of the star, that mere furnace which mere distance falsely sanctified, but of something other, which the dire contrast of the star and us signified to the heart. Yet what, what could thus be signified? Intellect, peering beyond the star, discovered no Star Maker, but only darkness; no Love, no Power even, but only Nothing. And yet the heart praised.\n\nApós um tempo indeterminado (dias? anos? milênios?) vivendo a sós com seus pensamentos, pensando que estava morto e preso numa espécie de limbo, o protagonista descobre como “voar” pelo espaço com a força do pensamento.\n\nThe sun was now but one among the other bright stars. Nothing changed. Was I doomed to hang thus for ever out in space, a bodiless view-point? Had I died? Was this my punishment for a singularly ineffectual life? Was this the penalty of an inveterate will to remain detached from human affairs and passions and prejudices?\n\n\n\n\nA bolota mágica\n\n\nCrendo-se um “enviado das estrelas” e sem chance de encontrar a Terra no meio de bilhões de estrelas, ele resolve investigar um a um dos planetas que encontra.\n\nI now hurried from star to star, a lost dog looking for its master. I rushed hither and thither, intent on finding a sun with planets, and among those planets my home.\n\nPercebe então que as estrelas ficaram mais claras e brilhantes, e conclui que na verdade voltou alguns bilhões de anos no tempo. Após mais alguns milênios à deriva, descobre finalmente um planeta habitado por uma espécie inteligente.\nStapledon descreve em detalhes como essa espécie se comunicava com cheiros, o sistema político, as guerras, as desigualdades sociais, etc. Por fim, o protagonista consegue conversar com um “filósofo” desse planeta, e ambos acabam se fundindo numa massa incorpórea e saem explorando o resto do Universo.\nO protagonista segue encontrando milhares de espécies: algumas se destruíram em guerras inúteis, outras se perderam por fenômenos naturais (supernovas, meteoros, fim da atmosfera). Suas formas são as mais variadas: simbioses entre pseudo-caranguejos e pseudo-golfinhos, “homens”-árvores, enxames de “abelhas” pensantes, hominídeos pequenos, caracois que nadavam por aí feito barcos, etc. Algumas conseguiram atingir um nível avançado através da inteligência e consciência coletiva feita por telepatia. Assim, os planetas se tornavam “um único ser consciente”, e essa consciência se espalhava para outros sistemas conforme a espécie avançava na exploração espacial.\n\nThere was a moment, late in this early phase of our pilgrimage, when, thinking and feeling in unison, we said to one another, “If the Star Maker is Love, we know that this must be right. But if he is not, if he is some other, some inhuman spirit, this must be right. And if he is nothing, if the stars and all else are not his creatures but self-subsistent, and if the adored spirit is but an exquisite creature of our minds, then this must be right, this and no other possibility. For we cannot know whether the highest place for love is on the throne or on the cross. We cannot know what spirit rules, for on the throne sits darkness. We know, we have seen, that in the waste of stars love is indeed crucified; and rightly, for its own proving, and for the throne’s glory. Love and all that is humane we cherish in our hearts. Yet also we salute the throne and the darkness upon the throne. Whether it be Love or not Love, our hearts praise it, out-soaring reason.”\n\n\n\n\n\n\nO livro acompanha o protagonista em sua jornada por fundir-se a mais inteligências, a ascenção e queda de espécies, a tentativa de Utopia galática, a descoberta de que até as nebulosas são seres “vivos”.\nNo clímax do livro, por uma fração minúscula de segundo, ele aparece: o criador de estrelas. O protagonista enxerga um clarão consumir o Universo inteiro, como se de repente todos os átomos do universo explodissem em luzes.\n\nIt seemed to me that the Star, my Maker, must surely stoop to meet me and raise me and enfold me in his radiance. For it seemed to me that I, the spirit of so many worlds, the flower of so many ages, was the Church Cosmical, fit at last to be the bride of God. But instead I was blinded and seared and struck down by terrible light.\n\n\nI saw that the virtue of the creature was to love and to worship, but the virtue of the creator was to create, and to be the infinite, the unrealizable and incomprehensible goal of worshipping creatures.\n\nEle enxerga como num filme rápido a morte térmica do Universo, quando o último ser vivo escondido no interior frio de um planeta se apaga pra sempre; enxerga o próprio fim de sua existência boiante num universo escuro, arrastado por um sono eterno.\nEle enxerga também o Universo como se fosse visto de fora, do ponto de vista do criador, do Starmaker. Percebe que existem milhares de universos, e que eles são como brinquedos nas mãos de um ser infinitamente poderoso. O criador-de-estrelas cria universos para explorar seus próprios poderes: o primeiro universo só possuía uma dimensão, e seus seres eram como ondas sonoras; depois disso, existiu um universo bidimensional; depois, o nosso universo usual com tempo e espaço; depois, um universo com várias dimensões espaciais e 2 dimensões temporais; e assim o criador experimentava com a Matéria até obter um universo tão complexo e perfeito que o faria dar-se por satisfeito. O Criador era como uma criança que descobria a si mesma através de suas obras.\n\nEternally, so my dream declared to me, the Star Maker is perfect and absolute; yet in the beginning of the time proper to his creative mode he was an infant deity, restless, eager, mighty, but without clear will. He was equipped with all creative power. He could make universes with all kinds of physical and mental attributes. He was limited only by logic. Thus he could ordain the most surprising natural laws, but he could not, for instance, make twice two equal five. In his early phase he was limited also by his immaturity. He was still in the trance of infancy. Though the unconscious source of his consciously exploring and creating mentality was none other than his own eternal essence, consciously he was at first but the vague blind hunger of creativity.\n\nEm alguns dos universos, o criador intervia dividindo-se em 2: um espírito de destruição e o outro de salvação. Em outros, ele alterava as leis da física quando lhe aprouvia. Na maioria dos universos, porém, ele apenas assistia impassível, além do bem e do mal.\n\nWhen he had given the last touches to all the cosmical ages from the supreme moment back to the initial explosion and on to the final death, the Star Maker contemplated his work. And he saw that it was good.\n\nApós ser inundado pelas sensações do último e perfeito universo feito pelo criador, o protagonista percebe que não consegue mais compreender as coisas; o entendimento lhe abandona, e depois de alguns instantes ele acorda na Terra, no morro onde havia ido passear.\nSem entender porra nenhuma."
  },
  {
    "objectID": "posts-livros/felicidade-imaginada/felicidade-imaginada.html",
    "href": "posts-livros/felicidade-imaginada/felicidade-imaginada.html",
    "title": "Sobre a felicidade presente e a felicidade futura",
    "section": "",
    "text": "A felicidade presente é sempre real, enquanto que a felicidade futura é uma aposta arriscada que poucas vezes cumpre as expectativas. Imagem tirada do excelente Extra Fabulous Comics.\n\n\n“Cândido, ou O Otimismo”, é um dos livros mais famosos da literatura universal. Neste conto filosófico, Voltaire narra com sua ironia peculiar as aventuras do ingênuo Cândido, que nasceu num palácio e se apaixonou pela bela Cunegundes. Lá também vivia o sábio Pangloss, que afirmava “estar demonstrado” que esse é o melhor dos mundos possíveis (ridicularizando Leibniz, o mesmo Leibniz do cálculo diferencial). Quando descobrem o romance de Cândido e Cunegundes, este é expulso do palácio e passa passa por várias aventuras e desgraças tentando reencontrar sua amada: é recrutado por búlgaros, sobrevive ao terremoto de Lisboa de 1755, vê Pangloss ser enforcado pela inquisição, foge pra América onde sem querer enfia uma espada no irmão de Cunegundes, é roubado, levado como escravo, mas por fim consegue reencontrar sua amada e casa-se com ela em Constantinopla onde vivem na pobreza.\nA última cena desse conto poderia ser um “e viveram felizes para sempre”, mas não é. Nela vemos um Cândido abatido, como que “morto por dentro”; Pangloss (que ainda estava vivo e vivendo com eles!) lhe diz:\n\n— Todos os acontecimentos — dizia às vezes Pangloss a Cândido — estão devidamente encadeados no melhor dos mundos possíveis; pois, afinal, se não tivesses sido expulso de um lindo castelo, a pontapés no traseiro, por amor da senhorita Cunegundes, se a Inquisição não te houvesse apanhado, se não tivesses percorrido a América a pé, se não tivesses mergulhado a espada no barão, se não tivesses perdido todos os teus carneiros da boa terra do Eldorado, não estarias aqui agora comendo doce de cidra e pistache.\n\nAo que Cândido lhe responde, finalizando a história:\n\n— Tudo isso está muito bem dito — respondeu Cândido, — mas devemos cultivar nosso jardim.\n\nImagino o pobre Cândido trabalhando à exaustão em seu jardim como um meio de esquecer a vida e apenas sobreviver, após tantos anos imaginando o quanto seria feliz ao reencontrar sua amada, que já não estava bela como antes e nem era tão amável quanto ele imaginava. Em sua última frase, Cândido mostra que as “vãs filosofias” não lhe interessam, e que é preciso trabalhar para viver. Como o Sísifo de Camus, é preciso imaginar Cândido feliz enquanto carregava sua pedra, isto é, enquanto fazia de tudo para reencontrar Cunegundes. Mas depois do encontro, o que lhe restou? A felicidade imaginada lhe pregou uma peça; o pêndulo de Schopenhauer é implacável.\n\nVoltaire deixa Cândido sozinho em seu jardim, com o peso da própria existência pairando em sua mente, num “zoom out” cruel. Não sabemos seu fim, nem o que se passa em sua cabeça: o retrato do Otimismo que precisou confrontar a realidade de um mundo “feito para nos dar raiva”, como dizia o cínico Martinho.\n\n\n\nCapa cabulosa da editora 34."
  },
  {
    "objectID": "posts-ds/symbolic regression/post.html#what-is-it",
    "href": "posts-ds/symbolic regression/post.html#what-is-it",
    "title": "Symbolic Regression in Julia",
    "section": "What is it?",
    "text": "What is it?\nA linear regression finds the line that is “closest” to a dataset. In a similar maner, a symbolic regression is an algorithm that find a combination of symbols that minimizes the mean square error of a given dataset. These symbols are unary and binary operators like the + symbol or a function like \\(cos\\) and \\(1/x\\)."
  },
  {
    "objectID": "posts-ds/symbolic regression/post.html#example-1",
    "href": "posts-ds/symbolic regression/post.html#example-1",
    "title": "Symbolic Regression in Julia",
    "section": "Example 1",
    "text": "Example 1\nLet’s try to approximate the function \\(f(x) = - x^2 + 1\\) using the symbols and \\(+, -, *\\) combined with the variable \\(x\\).\n\n# import Pkg; \n# Pkg.add([\"SymbolicRegression\", \"MLJ\", \"SymbolicUtils\", \"Plots\"])\n\n\nusing SymbolicRegression, MLJ, SymbolicUtils\nusing Plots\n\nx = [-3:0.1:3;]\ny = @. - x^2 + 1;\n\nscatter(x, y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst we define a model\n\nmodel = SRRegressor(\n    binary_operators=[+, -, *],    \n    niterations=50,\n    seed = 1\n);\n\n(Note: the argument seed = 1 is needed to ensure that the result is the same when this Quarto document compiles; you don’t need it.)\nAnd then fit it to our dataset\n\nX = reshape(x, (length(x), 1))\n\nmach = machine(model, X, y)\nfit!(mach)\n\nWe can see a report about the results:\n\nr = report(mach);\n\nr\n\n(best_idx = 2,\n equations = DynamicExpressions.EquationModule.Node{Float64}[-2.1000000000093864, 1.0 - (x₁ * x₁)],\n equation_strings = [\"-2.1000000000093864\", \"1.0 - (x₁ * x₁)\"],\n losses = [7.681799999999998, 0.0],\n complexities = [1, 5],\n scores = [36.04365338911715, 9.010913347279288],)\n\n\nThis report contains the losses\n\nr.losses\n\n2-element Vector{Float64}:\n 7.681799999999998\n 0.0\n\n\nthe equations\n\nr.equations\n\n2-element Vector{DynamicExpressions.EquationModule.Node{Float64}}:\n -2.1000000000093864\n 1.0 - (x₁ * x₁)\n\n\nand the best one of the functions found (ie. the one with the least loss):\n\nnode_to_symbolic(r.equations[r.best_idx], model)\n\n1.0 - (x1 * x1)\n\n\nHere, we can read \\(x_1\\) as \\(x\\), because we only have one variable.\nNotice that this expression simplifies to our original \\(f\\)."
  },
  {
    "objectID": "posts-ds/symbolic regression/post.html#example-2",
    "href": "posts-ds/symbolic regression/post.html#example-2",
    "title": "Symbolic Regression in Julia",
    "section": "Example 2",
    "text": "Example 2\nNow let’s get a more interesting example. Take \\(f(x) = x^2 + 2cos(x)^2\\):\n\ny = @. x^2 + 2cos(x)^2 \n\nscatter(x, y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe again create a model and fit it, but now we allow more operations: besides the earlier binary functions, we also have the unary cos function:\n\nmodel = SRRegressor(\n    binary_operators = [+, -, *],    \n    unary_operators = [cos],\n    niterations=50,\n    seed = 1\n);\n\nmach = machine(model, X, y)\nfit!(mach)\n\nand see the best equation:\n\nr = report(mach)\nnode_to_symbolic(r.equations[r.best_idx], model)\n\n(cos(x1 + x1) + (x1 * x1)) + cos(x1 - x1)\n\n\nSo, we got\n\\[\nx * x + cos(x + x) - (-1) = x^2 + cos(2x) + 1\n\\]\nSince \\(cos(2x) + 1 = 2cos^2(x)\\), we retrieve the original function."
  },
  {
    "objectID": "posts-ds/symbolic regression/post.html#example-3",
    "href": "posts-ds/symbolic regression/post.html#example-3",
    "title": "Symbolic Regression in Julia",
    "section": "Example 3",
    "text": "Example 3\nEven after adding some noise to the original dataset, the symbolic regression still can find a very good approximation:\nTake \\(f(x) = 0.3 * x^3 - x^2 + 2cos(x) + \\epsilon(x)\\) where \\(\\epsilon(x)\\) is a random uniform error (varying in \\([0, 1]\\)) like this:\n\nx = [-5:0.1:5;]\nX = reshape(x, (length(x), 1))\nerrors = rand(length(x))\ny = @. 0.3*x^3 - x^2 + 2cos(x) + errors\n\nscatter(x, y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodel = SRRegressor(\n    binary_operators = [+, -, *],    \n    unary_operators = [cos],\n    niterations=60,\n    seed = 1\n);\n\nmach = machine(model, X, y)\nfit!(mach)\n\nand see the best equation:\n\nr = report(mach)\nnode_to_symbolic(r.equations[r.best_idx], model)\n\n((x1 * (x1 * (-0.9967266849494391 - (x1 * -0.29956014260219427)))) + 0.4303333124180265) - (cos(x1) * -1.9543306909078142)\n\n\nWe can plot the prediction and the original dataset to compare them:\n\ny_pred = predict(mach, X)\n \nscatter(x, y);\nscatter!(x, y_pred, color = \"red\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNot bad at all!\nYou can see more about this package in this link. If you have enough courage, read the original paper on arxiv!"
  },
  {
    "objectID": "posts-livros/tchekhov-solidao/tchekov-solidao.html",
    "href": "posts-livros/tchekhov-solidao/tchekov-solidao.html",
    "title": "Sobre Tchekhov e as pequenas tragédias despercebidas",
    "section": "",
    "text": "Muitos contos de Tchekhov, o mestre da prosa curta, são como fotografias da alma humana. Através de situações comuns, de personagens humanos (sem heróis nem vilões), podemos ver recortes de vidas e o mundo subjetivo de personagens os mais diversos. Em poucas páginas tem-se ali, cristalizada, uma sensação que dificilmente conseguiria ser descrita de outro modo. Costumo pensar neles como um catálogo (ou paleta-de-cores) das situações humanas.\n\nEm “Angústia”, Tchekhov explora a solidão dos desprezados, a necessidade do Homem de ter uma palavra de compreensão, de poder contar uma tragédia pessoal e sentir um olhar de pena. Aos preguiçosos ou apressados, faço um resumo da história abaixo. Deixo entre aspas os trechos originais da tradução do Boris Schnaiderman.\nIona, um cocheiro pobre cujo filho morrera recentemente, não tinha “a quem confiar sua tristeza”. Acompanhamos Iona e seu cavalinho numa noite escura, próximos a uma praça, esperando passageiros.\nApós muito tempo imóvel sob a neve, surge um militar solicitando uma viagem curta. Com o coração pesado, Iona tenta contar-lhe:\n“- Pois é, meu senhor, assim é… perdi um filho esta semana…”\nO passageiro não lhe dá atenção. Na rua as pessoas trombam na carruagem de Iona e o xingam; o militar pede para Iona ir mais rápido. Chegando ao destino, Iona fica novamente parado em sua boleia, esperando, vendo as horas passar sob a neve, imóvel…\nPor fim, um grupo de bêbados (dentre eles um corcunda) sai de um bar e solicita uma viagem a Iona, pagando um valor muito abaixo do esperado. Ele aceita, pois é melhor do que nada. Os bêbados se xingam, brigam, caçoam do chapeu do cocheiro, dão-lhe tapas para ir mais rápido. Iona, em dado momento, tenta lhes contar:\n“– Esta semana… assim, perdi meu filho!\n– Todos vamos morrer. – suspira o corcunda, enxugando os lábios, após um acesso de tosse. – Bem, bate nele, bate nele! Minha gente, decididamente, não posso continuar andando assim! Esta corrida não acaba mais?\nE Iona volta-se, para contar como lhe morreu o filho, mas, nesse momento, o corcunda solta um suspiro de alívio e declara que, graças a Deus, chegaram ao destino.\nIona está novamente só e, de novo, o silêncio desce sobre ele… A angústia que amainara por algum tempo torna a aparecer, inflando-lhe o peito com redobrada força. Os olhos de Iona correm, inquietos e sofredores, pela multidão que se agita de ambos os lados da rua: não haverá, entre esses milhares de pessoas, uma ao menos que possa ouvi-lo? Mas a multidão corre, sem reparar nele, nem na sua angústia… Uma angústia imensa, que não conhece fronteiras. Dá a impressão de que, se o peito de Iona estourasse e dele fluísse para fora aquela angústia, daria para inundar o mundo e, no entanto, não se pode vê-la. Conseguiu caber numa casca tão insignificante, que não se pode percebê-la mesmo de dia, com muita luz…”\nIona resolve ir para casa. Seu cavalinho trota ligeiro.\nUma hora e meia depois, numa casa que dividia com outros cocheiros, Iona está sentado ao lado do fogão sujo. Há gente roncando por todos os lados; o ar é abafado, sufocante… Um cocheiro acorda para beber água, Iona tenta puxar conversa mas o homem logo volta a dormir.\n“É preciso contar como o filho adoeceu, como padeceu, o que disse antes de morrer e como morreu… É preciso descrever o enterro e a ida ao hospital, para buscar a roupa do defunto. Na aldeia, ficou a filha Aníssia… É preciso falar sobre ela também… De quantas coisas mais poderia falar agora? O ouvinte deve soltar exclamações, suspirar, lamentar… E é ainda melhor falar com mulheres. São umas bobas, mas desandam a chorar depois de duas palavras.”\nIona vai ao encontro de seu cavalinho no estábulo, e “pensa sobre a aveia, o feno, o tempo… Estando sozinho, não pode pensar no filho… Pode-se falar sobre ele com alguém, mas pensar nele sozinho, desenhar mentalmente sua imagem, dá um medo insuportável…\n– Está mastigando? – pergunta Iona ao cavalo, vendo seus olhos brilhantes. – Ora, mastiga, mastiga… Se não ganhamos para a aveia, vamos comer feno… Sim… Já estou velho para trabalhar de cocheiro… O filho é que devia trabalhar, não eu… Era um cocheiro de verdade… Só faltou viver mais…\nIona permanece algum tempo em silêncio e prossegue:\n– Assim é, irmão, minha egüinha… Não existe mais Kuzmá Iônitch… Foi-se para o outro mundo… Morreu assim, por nada… Agora, vamos dizer, você tem um potrinho, que é teu filho… E, de repente, vamos dizer, esse mesmo potrinho vai para o outro mundo… Dá pena, não é verdade?\nO cavalinho vai mastigando, escuta e sopra na mão de seu amo… Iona anima-se e conta-lhe tudo…”\n\nTudo o que sabemos da história de Iona são fragmentos que ele tenta contar aos outros e alguns poucos pensamentos que ele tem.\nTchekhov não nos narra a doença do filho de Iona, as angústias do pai, as idas ao hospital, a notícia da morte, o enterro, o luto… sabemos apenas que essas coisas aconteceram e que Iona queria contá-las a alguém, queria que alguém o ouvisse como a um irmão. Vemos Iona e seu cavalinho sob a neve, esperando passageiros; vemos Iona tentando esvaziar o coração e sendo desprezado, sentimos a indeferença dos outros ante morte de seu filho, e o vemos seguindo solitário até chegar em casa… por fim, o único que o ouviu foi seu cavalo.\nIona até tenta fazer o cavalo entender melhor a situação (“Agora, vamos dizer, você tem um potrinho, que é teu filho… E, de repente, vamos dizer, esse mesmo potrinho vai para o outro mundo… Dá pena, não é verdade?”), e podemos imaginar a cena: um senhorzinho conversando com seu cavalo, no escuro, sob a neve, ao lado da casinha mal iluminada. Um homem sozinho no mundo, cujo único ouvinte sobre a tristeza que lhe devorava era o próprio instrumento de trabalho. O conto acaba ali: Iona em seu monólogo. Não sabemos o que acontece depois. Tchekhov larga a pena quando percebe que acabou seu retrato claro sobre a angústia humana, que passou despercebida por quem viu o cocheiro Iona naquela noite."
  },
  {
    "objectID": "posts-livros/eletronic-bard/eletronic-bard.html",
    "href": "posts-livros/eletronic-bard/eletronic-bard.html",
    "title": "A era das máquinas artistas e o bardo eletrônico de Lem",
    "section": "",
    "text": "Ou: como Stanislaw Lem fantasiou uma versão exagerada do chatGPT na década de 60.\n“Trurl, o famoso construtor, um dia resolveu criar uma máquina que escrevia poesia para provar a seu amigo Klapaucius quem era o melhor construtor do universo.”\nMais ou menos assim começa o conto “The eletronic Bard” the Stanislaw Lem, escrito na década de 60. Publicado no livro “Cyberiads”, inaugurou um gênero literário bizarro que mistura ficção científica e contos de fada medievais com a ironia de Voltaire e a prosa macarrônica de Rabelais. O livro narra as aventuras de Trurl e Klapaucius, dois robôs inventores capazes de criar praticamente qualquer coisa (como a máquina que materializava tudo que começava com “n”, ou uma miniatura de um reino que se revoltou contra o rei, ou o robô gigante que dizia que 2+2 é 7 e tentou matar Trurl, ou a máquina que imprimia todas as verdades do universo). Ambos tentam cumprir pedidos quase impossíveis de reis de toda a galáxia em troca de ouro, e quase sempre acabam arrumando problema e tendo que fugir.\nGosto tanto dessa história que vou recontar ela do meu jeito abaixo, entre aspas:\n“Trurl juntou 820 toneladas de livros sobre cibernética e 1200 toneladas de livros de poesia e se pôs a ler. Quando cansava de uma equação, lia um verso1. Percebeu então que a parte mais difícil da máquina seria o programa em si, e não o hardware. O ‘programa’ na cabeça de um poeta era, afinal, escrito pela civilização do poeta; e esta, por sua vez, era fruto das civilizações anteriores. Trurl então percebeu que seria mais fácil criar um universo virtual (desde o big bang!) e deixar naturalmente o poeta surgir de uma versão cibernética da Terra.”\nAqui há um paralelo interessante com os large language models (LLM) atuais, como o ChatGPT e o Google Bard2: em vez de ensinar gramática e rimas e poesia a um algoritmo (isto é: em vez de passar todas as instruções uma a uma, como se ensinaria um robô obediente), hoje monta-se uma arquitetura de rede neural capaz de aprender a interpretar textos, e então alimenta-se essa rede neural com bilhões de textos até ela aprender sozinha a falar uma linguagem e responder a humanos. Parecido com o modo como os bebês aprendem a falar!\nNo fim da década de 50 as redes neurais ficaram famosas por prometerem imitar o aprendizado do cérebro humano. Criou-se muita expectativa sobre robôs que pensavam como humanos e andariam por aí resolvendo tarefas difíceis. Porém, a falta de poder computacional da época e alguns projetos fracassados levaram ao “inverno da IA” que durou várias décadas. Por isso talvez para Lem parecia impossível um robô poeta, objeto de um conto rocambólico do Cyberiads.\nA história segue:\n“Após os preparativos, a simulação do universo começou. Trurl foi adicionando mais e mais processadores ao computador, e teve que reinciar a simulação duas vezes: uma porque um fusível queimado fez Abel matar Caim, e na outra porque algo errado aconteceu na árvore evolutiva e em vez de termos os grandes macacos (great apes) surgiram cortinas cinzas (gray drapes). Passou-se a Antiguidade, a Idade Média, as reformas, e as revoluções. Ao chegar no século 20, com as grandes guerras, Trurl teve que jogar água na máquina que não parava de esquentar e vibrar. Civilizações surgiram e se foram a cada 25 mil anos, e Trurl precisava adicionar mais e mais fitas para salvar todos os dados. Tudo isso para obter um poeta!\nApós milhões de anos na simulação, Trurl escolheu o melhor poeta de todos. Ajustando o sensor de emotividade, adicionando um campo semântico e uma alavanca filosófica, tudo o que o poeta disse foi “Eu tinha um sapo”. Trurl continuou mexendo na máquina, adicionando filtros de clichê, um alternador de rimas, retirando alguns circuitos lógicos e por fim colocando um narcistor egocentripetal3 até que ela finalmente produziu um poema razoável.\nExtasiado, Trurl chamou Klapaucius para ver sua criação. Klapaucius estava cético e a princípio achou que os poemas do bardo eletrônico já estavam escritos num banco de dados, e que o bardo era apenas um recitador de coisas prontas. Para testá-lo, pediu que ele fizesse ‘um poema de amor, lírico, pastoral, expresso na linguagem da matemática pura; com bastante álgebra tensorial, um pouco de topologia e talvez cálculo avançado.’ Trurl ficou indignado e com medo de que o bardo quebrasse, mas ele começou um enorme poema assim4:\nKlapaucius inventou uma desculpa qualquer e foi embora, visivelmente abalado.\nPouco tempo se passou até que notícias sobre o bardo chegassem nos poetas genuínos - isto é, ordinários. Ofendidos, resolveram ignorar a existência da máquina. Mas alguns curiosos foram visitar o bardo, que os recebeu educadamente com suas pilhas de poemas. Esses poetas eram vanguardistas, e o bardo escrevia apenas no estilo clássico. Os poetas caçoaram dele e foram embora. A máquina, porém, se auto-programava, e além disso tinha um aplificador-de-ambição com circuitos de busca-pela-glória. Rapidamente notou-se uma mudança: o bardo começou a fazer poemas tão intrincados e carregados de significados que se tornaram praticamente incompreensíveis.\nOs poetas continuavam indo até a casa de Trurl encontrar o bardo, mas mal começavam um poema e o bardo, imitando o estilo do poeta, lançava torrentes de rimas para humilhar o pobre visitante. Alguns poetas cometeram suicídio, outros organizaram protestos exigindo o desligamento da máquina, mas além deles ninguém parecia se importar: o bardo, escrevendo sob centenas de pseudônimos, tinha um poema para cada ocasião, do tamanho desejado, e de tal qualidade que qualquer revista seria comprada apenas pelos versos. Todos conheciam os poemas do bardo eletrônico de Trurl e suas rimas deliciosas; elas estavam em todos os jornais e revistas. Alguns até desmaiavam de prazer ao ler seus poemas.”\nAqui outro paralelo curiosíssimo com a atualidade: artistas protestando contra a arte gerada por IAs, enquanto empresas usam essas tecnologias para diminuir custos. Para um dono de empresa, é mais barato pagar o ChatGPT4 do que um redator, ou gerar imagens pelo Dall-E 3 do que pagar um ilustrador. Além dos próprios artistas, são poucos os que se incomodam a ponto de ir contra as máquinas artistas.\n“Trurl começou a ter problemas por causa de sua invenção. Os poetas clássicos não lhe incomodavam, pois eram quase todos velhos e inofensivos; se limitavam a jogar pedras na sua casa ou esfregar susbtâncias mal-cheirosas em suas paredes. Os mais novos, porém, já eram piores: um deles era tão bom com versos quanto na porrada e fez Trurl parar no hospital. Ainda internado, os protestos continuavam. Mais e mais poetas levavam maletas com rifles em vez de poemas para tentar destruir o bardo: vão, pois as balas ricocheteavam em seu enorme exterior metálico. Ao sair do hospital, Trurl decidiu então desligar o bardo para sempre para poder ter paz.\nMas, ao aproximar-se mancando da máquina, ela percebeu a intenção de Trurl e recitou um pedido de misericórdia tão eloquente e apaixonado que o famoso construtor saiu dali em lágrimas. No mês seguinte, ao receber a conta de energia elétrica, Trurl quase caiu de sua cadeira. Durante a noite, desligou o bardo da tomada, desmontou-o, colocou-o em sua nave e levou-o até um asteroide, onde o montou junto de uma pilha de material radiativo para servir de energia.\nA história não acaba aí. O bardo, sem ter como publicar seus poemas, resolveu transmiti-los em todas as frequências de onda, fazendo com que os passageiros das naves que por ali passavam entrassem num estado de estupefação e sofressem ataques de êxtase. O Comando das Frotas Cósmicas enviou um time de técnicos para resolver o problema, mas o bardo improvisou diversas baladas que os fizeram chorar. Resolveram então enviar outro time de técnicos, dessa vez surdos, mas a máquina fez uso de pantomimas e também eles ficaram maravilhados. Após isso, começou-se a aventar a possibilidade de uma bomba atômica no asteroide, mas um rei de uma estrela vizinha apareceu e levou a máquina embora para seu reino.\nFinalmente Trurl pôde voltar a aparecer em público.\nAlgumas supernovas começaram a explodir de maneira estranha no horizonte, e havia rumores de que isso estava relacionado com poesia. De acordo com um relato, o rei que levou o bardo, movido por um estranho capricho, havia conectado o bardo a uma constelação de supergigantes, transformando cada linha de verso em uma estupenda proeminência solar: assim, o maior poeta do universo era capaz de transmitir suas criações termonucleares para todo o espaço. Mesmo que esse relato fosse verdadeiro, era distante demais para incomodar Trurl, que jurou nunca mais fazer um modelo cibernético da Musa.”\nO que acontecerá quando as máquinas quiserem continuar produzindo arte e ninguém mais for consumi-las? Será que elas aprenderão a apreciar a arte uma das outras como nós fazemos? As máquinas artistas de hoje estão quase a ponto de superar o brilhante bardo eletrônico do Lem, e é difícil imaginar o que virá depois…"
  },
  {
    "objectID": "posts-livros/eletronic-bard/eletronic-bard.html#footnotes",
    "href": "posts-livros/eletronic-bard/eletronic-bard.html#footnotes",
    "title": "A era das máquinas artistas e o bardo eletrônico de Lem",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nera assim que eu estudava Análise Funcional no doutorado↩︎\nque não tem relação com o Eletronic Bard do Lem, e sim com Shakespeare↩︎\nLem é um mestre na arte de inventar nomes ridículos que parecem de verdade↩︎\ndeixei o poema em inglês como na versão que li; o original é em polonês, e vou evitar aqui a lambança de traduzir uma tradução↩︎"
  },
  {
    "objectID": "posts-ds/julia-for-r-users/post.html",
    "href": "posts-ds/julia-for-r-users/post.html",
    "title": "Julia for R users",
    "section": "",
    "text": "I know a lot of R and can do my daily job with it. Why should I learn Julia?\n\nIn my case, I was looking for some adventure. Haskell seemed too hard, Python too normal. So I went on a journey to learn Julia and was very happy with what I discovered.\nBelow is a (biased) list of advantages of Julia compared to R:\n\n\nIn R, whenever you need some really fast code (as fast as you would get in C), you have to use C or Fortran code. R is simply slow. If you need speed in R, you will have to find a package that already implements what you need or learn C/Fortran, use RCpp and pray.\n\n\n\nstringi package sourcecode.\n\n\nIn Julia, you won’t need other language to get speed close to C. That’s way they say that Julia solves the two language problem. Julia packages are almost always 100% Julia, which means that you can look to its sourcecode and learn a lot.\n\n\n\nImages that make you cry: the deep learning package Flux.jl.\n\n\nThis is specially interesting if you read Julia Base sourcecode! How does Julia define the maximum of a vector? Type\n\n@edit maximum([1:5;])\n\nand you will see this:\n\n\n\nThe sourcecode of the function maximum applied to a vector.\n\n\nIt takes some time to grasp the meaning, but in the end it says “apply a mapreduce into the vector, using the max function on each pair of numbers”. In R, the sourcecode is a sad .Primitive(\"max\").\n\n\n\nJulia has a special notation . (yes, a dot) to apply any function to a vector/array/iterable-object; this is called broadcasting. For example, you can apply the power2 function in a vector as easy as\n\n#julia\n# define power2 for numbers\npower2(x) = x^2;\n\n# apply in vectors\npower2.(1:10)\n\n10-element Vector{Int64}:\n   1\n   4\n   9\n  16\n  25\n  36\n  49\n  64\n  81\n 100\n\n\nor in a matrix\n\n#julia\nX = reshape([1:16;], (4, 4))\n\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\n\n\n#julia\npower2.(X)\n\n4×4 Matrix{Int64}:\n  1  25   81  169\n  4  36  100  196\n  9  49  121  225\n 16  64  144  256\n\n\nWhen using infix functions like + or =, you put the dot before the operator, as in\n\n#julia\n[1:5;] .+ 10\n\n5-element Vector{Int64}:\n 11\n 12\n 13\n 14\n 15\n\n\nIn R, you always try to avoid loops because they are slow. Suppose you have a vector and want to sum 1 to every entry. As an experienced R programmer, you look for a vectorized approach:\n#| eval: false\n# R\nf1_vec = function(x) {\n    y = x + 1\n}\ninstead of a loop\n#| eval: false\n# R\nf1_loop = function(x) {\n    y = x\n    for (i in seq_along(x)) y[i] = x[i] + 1\n    y\n}\nor a even a purrr::map approach\n#| eval: false\n#R\nf1_map = function(x) {\n    purrr::map_dbl(x, \\(xi) xi + 1)\n}\nbecause the first options is faster. We can see the difference:\n#| eval: false\n# R\nx = 1:100000\n\nbench::mark(\n    f1_vec(x)\n    ,f1_loop(x)\n    ,f1_map(x)\n    ,relative = TRUE\n)\n\n#R\nR\"\"\"\nf1_vec = function(x) {\n    y = x + 1\n}\n\nf1_loop = function(x) {\n    y = x\n    for (i in seq_along(x)) y[i] = x[i] + 1\n    y\n}\n\nf1_map = function(x) {\n    purrr::map_dbl(x, \\(xi) xi + 1)\n}\n\nx = 1:100000\n\nbench::mark(\n    f1_vec(x)\n    ,f1_loop(x)\n    ,f1_map(x)\n    ,relative = TRUE\n)\n\"\"\"\n\n┌ Warning: RCall.jl: Aviso: Some expressions had a GC in every iteration; so filtering is disabled.\n└ @ RCall ~/.julia/packages/RCall/0ggIQ/src/io.jl:172\n\n\nRObject{VecSxp}\n# A tibble: 3 × 13\n  expression   min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time\n  &lt;bch:expr&gt; &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt;   &lt;bch:tm&gt;\n1 f1_vec(x)    1      1       124.       1        11.1   828    11      500ms\n2 f1_loop(x)  44.6   13.6      10.6      1.03      1      72     1      506ms\n3 f1_map(x)  542.   147.        1        1.01     33.8     7    35      523ms\n# ℹ 4 more variables: result &lt;list&gt;, memory &lt;list&gt;, time &lt;list&gt;, gc &lt;list&gt;\n\n\nIn my machine, the loop is ~40x slower and the map ~500x slower than the vectorized version.\nIn Julia, the three approachs are similar:\n\n#julia\nf1_vec(x) = x .+ 1;\n\nfunction f1_loop(x)\n    y = similar(x)\n    @inbounds for i ∈ eachindex(x) y[i] = x[i] + 1 end\n    y\nend;\n\nfunction f1_map(x)\n    map(x) do xi\n        xi + 1 \n    end\nend;\n\n\n#julia\nusing BenchmarkTools;\nx = [1:100000;];\n\n@benchmark f1_vec($x)\n\n\n#julia\n@benchmark f1_loop($x)\n\n\n#julia\n@benchmark f1_map($x)\n\nThis means that in Julia it is usual to define a function using a scalar type (a Number like Float64/Int or a String) and then use broadcast to apply the function to vectors/matrices/etc.\n\n\n\n\n\n\nA type system is a way to create a hierarchy of data ……….?\nConsider de print function in R. It is a generic function, which means that its behaviour depends on the class of its first argument. This can be seen when we look to its misterious source code:\n\n\n\nThe print function sourcecode.\n\n\nwhich means that print will use several methods, one for each class. Actually, R just creates a different function for each class, with the pattern function.class:\n\n\n\nEach method/implementation of the generic function print.\n\n\nIn Julia, every function is generic. This means that we can use the same function name and define different behaviours/implementations for each combination of classes/types of its arguments.\n\n\n\n\n\n\n\n\n\nIn R, you have 2 options to call a function from another package:\n\nuse library(PACKAGE) and then import every function from PACKAGE to your namespace;\nuse PACKAGE::FUNCTION every time you want to use a function.\n\nIn Julia, you have more options:\n\na\nb\nc\n\nThere is also the possibility to create modules inside modules (which are like packages inside packages). For example, if you have a package to train machine learning modules, you can have a module about Metrics, another one with Models and so on. Importing then can be done with\n\nusing MyPackage.Metrics\n\n# or\nimport MyPackage.Models as MD"
  },
  {
    "objectID": "cv.html#talks-workshops-and-papers",
    "href": "cv.html#talks-workshops-and-papers",
    "title": "About me",
    "section": "Talks, workshops and papers",
    "text": "Talks, workshops and papers\n\nPaper: Motivic clustering schemes for directed graphs (2000, published in ArXiv, with Facundo Mémoli).\nTalk: Topology meets the real world: how geometry can help us analyse finite metric spaces (2023, at the Workshop of Algebraic Topology and Applications).\nWorkshop: Topological Data Analysis workshop (2024, at the XXIII Brazilian Topology Meeting).\nPaper: Remote sensing to quantify potential aquifer recharge as a complementary tool for groundwater monitoring (2024, published in Hydrological Sciences Journal), co-author."
  },
  {
    "objectID": "cv.html#footnotes",
    "href": "cv.html#footnotes",
    "title": "About me",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nCV model credits: https://www.cynthiahqy.com/posts/cv-html-pdf/↩︎"
  },
  {
    "objectID": "posts-ds/julia-for-r-users/post.html#fast-julia-code-is-written-in-julia-fast-r-code-is-not-written-in-r",
    "href": "posts-ds/julia-for-r-users/post.html#fast-julia-code-is-written-in-julia-fast-r-code-is-not-written-in-r",
    "title": "Julia for R users",
    "section": "",
    "text": "In R, whenever you need some really fast code (as fast as you would get in C), you have to use C or Fortran code. R is simply slow. If you need speed in R, you will have to find a package that already implements what you need or learn C/Fortran, use RCpp and pray.\n\n\n\nstringi package sourcecode.\n\n\nIn Julia, you won’t need other language to get speed close to C. That’s way they say that Julia solves the two language problem. Julia packages are almost always 100% Julia, which means that you can look to its sourcecode and learn a lot.\n\n\n\nImages that make you cry: the deep learning package Flux.jl.\n\n\nThis is specially interesting if you read Julia Base sourcecode! How does Julia define the maximum of a vector? Type\n\n@edit maximum([1:5;])\n\nand you will see this:\n\n\n\nThe sourcecode of the function maximum applied to a vector.\n\n\nIt takes some time to grasp the meaning, but in the end it says “apply a mapreduce into the vector, using the max function on each pair of numbers”. In R, the sourcecode is a sad .Primitive(\"max\")."
  },
  {
    "objectID": "posts-ds/julia-for-r-users/post.html#loops-are-fast-do-not-vectorize-code",
    "href": "posts-ds/julia-for-r-users/post.html#loops-are-fast-do-not-vectorize-code",
    "title": "Julia for R users",
    "section": "",
    "text": "In R, you always try to avoid loops because they are slow. For example, if I have a vector\n\nx = 1:100000\n\nand want to sum 1 to every entry, you look for a vectorized approach:\n\n# R\ny = x + 1\n\ninstead of\n\n# R\ny = x\n\nfor (i in seq_along(x)) y[i] = x[i] + 1\n\nbecause the former is faster. We can see the difference:\n\n# R\nbench::mark(\n    y = x + 1\n    ,{\n        y = x\n        for (i in seq_along(x)) y[i] = x[i] + 1\n        y\n    }\n)\n\n# A tibble: 2 × 6\n  expression                           min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;                      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 y                               142.31µs 529.12µs     1770.   781.3KB    25.6 \n2 { y = x for (i in seq_along(x)…   8.39ms   9.64ms      102.    1.16MB     2.05"
  },
  {
    "objectID": "posts-ds/julia-for-r-users/post.html#multiple-dispatch",
    "href": "posts-ds/julia-for-r-users/post.html#multiple-dispatch",
    "title": "Julia for R users",
    "section": "",
    "text": "Every function in Julia is generic"
  },
  {
    "objectID": "posts-ds/julia-for-r-users/post.html#no-need-to-vectorize-code-loops-maps-and-broadcast-are-fast-enough",
    "href": "posts-ds/julia-for-r-users/post.html#no-need-to-vectorize-code-loops-maps-and-broadcast-are-fast-enough",
    "title": "Julia for R users",
    "section": "",
    "text": "Julia has a special notation . (yes, a dot) to apply any function to a vector/array/iterable-object; this is called broadcasting. For example, you can apply the power2 function in a vector as easy as\n\n#julia\n# define power2 for numbers\npower2(x) = x^2;\n\n# apply in vectors\npower2.(1:10)\n\n10-element Vector{Int64}:\n   1\n   4\n   9\n  16\n  25\n  36\n  49\n  64\n  81\n 100\n\n\nor in a matrix\n\n#julia\nX = reshape([1:16;], (4, 4))\n\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\n\n\n#julia\npower2.(X)\n\n4×4 Matrix{Int64}:\n  1  25   81  169\n  4  36  100  196\n  9  49  121  225\n 16  64  144  256\n\n\nWhen using infix functions like + or =, you put the dot before the operator, as in\n\n#julia\n[1:5;] .+ 10\n\n5-element Vector{Int64}:\n 11\n 12\n 13\n 14\n 15\n\n\nIn R, you always try to avoid loops because they are slow. Suppose you have a vector and want to sum 1 to every entry. As an experienced R programmer, you look for a vectorized approach:\n#| eval: false\n# R\nf1_vec = function(x) {\n    y = x + 1\n}\ninstead of a loop\n#| eval: false\n# R\nf1_loop = function(x) {\n    y = x\n    for (i in seq_along(x)) y[i] = x[i] + 1\n    y\n}\nor a even a purrr::map approach\n#| eval: false\n#R\nf1_map = function(x) {\n    purrr::map_dbl(x, \\(xi) xi + 1)\n}\nbecause the first options is faster. We can see the difference:\n#| eval: false\n# R\nx = 1:100000\n\nbench::mark(\n    f1_vec(x)\n    ,f1_loop(x)\n    ,f1_map(x)\n    ,relative = TRUE\n)\n\n#R\nR\"\"\"\nf1_vec = function(x) {\n    y = x + 1\n}\n\nf1_loop = function(x) {\n    y = x\n    for (i in seq_along(x)) y[i] = x[i] + 1\n    y\n}\n\nf1_map = function(x) {\n    purrr::map_dbl(x, \\(xi) xi + 1)\n}\n\nx = 1:100000\n\nbench::mark(\n    f1_vec(x)\n    ,f1_loop(x)\n    ,f1_map(x)\n    ,relative = TRUE\n)\n\"\"\"\n\n┌ Warning: RCall.jl: Aviso: Some expressions had a GC in every iteration; so filtering is disabled.\n└ @ RCall ~/.julia/packages/RCall/0ggIQ/src/io.jl:172\n\n\nRObject{VecSxp}\n# A tibble: 3 × 13\n  expression   min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time\n  &lt;bch:expr&gt; &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt;   &lt;bch:tm&gt;\n1 f1_vec(x)    1      1       124.       1        11.1   828    11      500ms\n2 f1_loop(x)  44.6   13.6      10.6      1.03      1      72     1      506ms\n3 f1_map(x)  542.   147.        1        1.01     33.8     7    35      523ms\n# ℹ 4 more variables: result &lt;list&gt;, memory &lt;list&gt;, time &lt;list&gt;, gc &lt;list&gt;\n\n\nIn my machine, the loop is ~40x slower and the map ~500x slower than the vectorized version.\nIn Julia, the three approachs are similar:\n\n#julia\nf1_vec(x) = x .+ 1;\n\nfunction f1_loop(x)\n    y = similar(x)\n    @inbounds for i ∈ eachindex(x) y[i] = x[i] + 1 end\n    y\nend;\n\nfunction f1_map(x)\n    map(x) do xi\n        xi + 1 \n    end\nend;\n\n\n#julia\nusing BenchmarkTools;\nx = [1:100000;];\n\n@benchmark f1_vec($x)\n\n\n#julia\n@benchmark f1_loop($x)\n\n\n#julia\n@benchmark f1_map($x)\n\nThis means that in Julia it is usual to define a function using a scalar type (a Number like Float64/Int or a String) and then use broadcast to apply the function to vectors/matrices/etc."
  },
  {
    "objectID": "posts-ds/julia-for-r-users/post.html#multiple-dispatch-and-a-rich-type-system",
    "href": "posts-ds/julia-for-r-users/post.html#multiple-dispatch-and-a-rich-type-system",
    "title": "Julia for R users",
    "section": "",
    "text": "A type system is a way to create a hierarchy of data ……….?\nConsider de print function in R. It is a generic function, which means that its behaviour depends on the class of its first argument. This can be seen when we look to its misterious source code:\n\n\n\nThe print function sourcecode.\n\n\nwhich means that print will use several methods, one for each class. Actually, R just creates a different function for each class, with the pattern function.class:\n\n\n\nEach method/implementation of the generic function print.\n\n\nIn Julia, every function is generic. This means that we can use the same function name and define different behaviours/implementations for each combination of classes/types of its arguments."
  },
  {
    "objectID": "posts-ds/julia-for-r-users/post.html#modules-and-packages-are-a-joy-to-use",
    "href": "posts-ds/julia-for-r-users/post.html#modules-and-packages-are-a-joy-to-use",
    "title": "Julia for R users",
    "section": "",
    "text": "In R, you have 2 options to call a function from another package:\n\nuse library(PACKAGE) and then import every function from PACKAGE to your namespace;\nuse PACKAGE::FUNCTION every time you want to use a function.\n\nIn Julia, you have more options:\n\na\nb\nc\n\nThere is also the possibility to create modules inside modules (which are like packages inside packages). For example, if you have a package to train machine learning modules, you can have a module about Metrics, another one with Models and so on. Importing then can be done with\n\nusing MyPackage.Metrics\n\n# or\nimport MyPackage.Models as MD"
  },
  {
    "objectID": "posts-ds/julia-for-r-users/julia-for-r-users.html",
    "href": "posts-ds/julia-for-r-users/julia-for-r-users.html",
    "title": "Julia for R users",
    "section": "",
    "text": "I know a lot of R and can do my daily job with it. Why should I learn Julia?\nIn my case, I was looking for some adventure. Haskell seemed too hard, Python too normal. So I went on a journey to learn Julia and was very happy with what I discovered.\nI love R, it is my breadwinner (and has been for the past 6 years), and I know some of its limitations. So below is a (biased) list of features that may interest you in trying Julia:"
  },
  {
    "objectID": "posts-ds/julia-for-r-users/julia-for-r-users.html#fast-julia-code-is-written-in-julia-fast-r-code-is-not-written-in-r",
    "href": "posts-ds/julia-for-r-users/julia-for-r-users.html#fast-julia-code-is-written-in-julia-fast-r-code-is-not-written-in-r",
    "title": "Julia for R users",
    "section": "Fast Julia code is written in Julia; fast R code is not written in R",
    "text": "Fast Julia code is written in Julia; fast R code is not written in R\nIn R, whenever you need some really fast code (as fast as you would get in C), you have to use C or Fortran code. R is simply slow. If you need speed in R, you will have to find a package that already implements what you need or learn C/Fortran, use RCpp and pray.\n\n\n\nstringi package sourcecode.\n\n\nIn Julia, you won’t need other language to get speed close to C. That’s way they say that Julia solves the two language problem. Julia packages are almost always 100% Julia, which means that you can look to its sourcecode and learn a lot.\n\n\n\nImages that make you cry: the deep learning package Flux.jl.\n\n\nThis is specially interesting if you read Julia Base sourcecode! How does Julia define the maximum of a vector? Type\n\n@edit maximum([1:5;])\n\nand you will see this:\n\n\n\nThe sourcecode of the function maximum applied to a vector.\n\n\nIt takes some time to grasp the meaning, but in the end it says “apply a mapreduce into the vector, using the max function on each pair of numbers”. In R, the sourcecode is a sad .Primitive(\"max\")."
  },
  {
    "objectID": "posts-ds/julia-for-r-users/julia-for-r-users.html#no-need-to-vectorize-code-loops-maps-and-broadcast-are-fast-enough",
    "href": "posts-ds/julia-for-r-users/julia-for-r-users.html#no-need-to-vectorize-code-loops-maps-and-broadcast-are-fast-enough",
    "title": "Julia for R users",
    "section": "No need to vectorize code; loops, maps and broadcast are fast enough",
    "text": "No need to vectorize code; loops, maps and broadcast are fast enough\nTired of writing loops? Julia has a special notation . (yes, a dot) to apply any function to a vector/array/iterable-object; this is called broadcasting. For example, you can apply the power2 function in a vector as easy as\n\n#julia\n# define power2 for numbers\npower2(x) = x^2;\n\n# apply in vectors\npower2.(1:10)\n\n10-element Vector{Int64}:\n   1\n   4\n   9\n  16\n  25\n  36\n  49\n  64\n  81\n 100\n\n\nor in a matrix\n\n#julia\nX = reshape([1:16;], (4, 4))\n\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\n\n\n#julia\npower2.(X)\n\n4×4 Matrix{Int64}:\n  1  25   81  169\n  4  36  100  196\n  9  49  121  225\n 16  64  144  256\n\n\nWhen using infix functions like + or =, you put the dot before the operator, as in\n\n#julia\n[1:5;] .+ 10\n\n5-element Vector{Int64}:\n 11\n 12\n 13\n 14\n 15\n\n\nIn R, you always try to avoid loops because they are slow. Suppose you have a vector and want to sum 1 to every entry. As an experienced R programmer, you look for a vectorized approach:\n# R\nf1_vec = function(x) {\n    y = x + 1\n}\ninstead of a loop\n# R\nf1_loop = function(x) {\n    y = x\n    for (i in seq_along(x)) y[i] = x[i] + 1\n    y\n}\nor a even a purrr::map approach (if you are in a functional programming mood)\n#R\nf1_map = function(x) {\n    purrr::map_dbl(x, \\(xi) xi + 1)\n}\nbecause the first options is faster. We can see the difference:\n# R\nx = 1:100000\n\nbench::mark(\n    f1_vec(x)\n    ,f1_loop(x)\n    ,f1_map(x)\n    ,relative = TRUE\n)\n\n\nRObject{VecSxp}\n# A tibble: 3 × 13\n  expression   min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time\n  &lt;bch:expr&gt; &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt;   &lt;bch:tm&gt;\n1 f1_vec(x)    1      1       121.       1        10.0   744    10      500ms\n2 f1_loop(x)  44.8   12.6      11.7      1.03      1      72     1      501ms\n3 f1_map(x)  582.   145.        1        1.00     30.8     7    35      568ms\n# ℹ 4 more variables: result &lt;list&gt;, memory &lt;list&gt;, time &lt;list&gt;, gc &lt;list&gt;\n\n\nIn my machine, the loop is ~40x slower and the map ~500x slower than the vectorized version.\nThe problem is when the function you want to apply have no vectorized form.\nIn Julia, the three approachs are similar:\n\n#julia\nf1_vec(x) = x .+ 1;\n\nfunction f1_loop(x)\n    y = similar(x)\n    @inbounds for i ∈ eachindex(x) y[i] = x[i] + 1 end\n    y\nend;\n\nfunction f1_map(x)\n    map(x) do xi\n        xi + 1 \n    end\nend;\n\n\n#julia\nusing BenchmarkTools;\nx = [1:100000;];\n\n@benchmark f1_vec($x)\n\n\n#julia\n@benchmark f1_loop($x)\n\n\n#julia\n@benchmark f1_map($x)\n\nThis means that in Julia it is usual to define a function using a scalar type (a Number like Float64/Int or a String) and then use broadcast to apply the function to vectors/matrices/etc. No need to create vectorized forms of functions anymore!"
  },
  {
    "objectID": "posts-ds/julia-for-r-users/julia-for-r-users.html#multiple-dispatch-and-a-rich-type-system",
    "href": "posts-ds/julia-for-r-users/julia-for-r-users.html#multiple-dispatch-and-a-rich-type-system",
    "title": "Julia for R users",
    "section": "Multiple dispatch and a rich type system",
    "text": "Multiple dispatch and a rich type system\nA type system is a way to organize a hierarchy of data types. Think of it as mathematical sets: you have the real numbers, and inside it are the rationals, the integers and so on. Each one of these types store data in a different manner (integers can be stored more efficiently than arbitrary real numbers, for example). Julia has a really nice type system. Let’s see some examples to better understand it.\nConsider the print function in R. It is a generic function, which means that its behaviour depends on the class of its first argument. This can be seen when we look to its misterious source code:\n\n\n\nThe print function sourcecode.\n\n\nwhich means that print will use several methods (code), one for each class/type. Actually, R just creates a different function for each class, with the pattern {function}.{class}:\n\n\n\nEach method/implementation of the generic function print.\n\n\nIn Julia, every function is generic. This means that we can use the same function name and define different behaviours/implementations for each combination of classes/types of its arguments. We saw above the implementation of the maximum function in Julia for an arbitrary vector of numbers. But what if the vector is of a different kind, which is easier to determine the maximum?\nTake, for example, the object\n\nx = 1:10\n\n1:10\n\n\nIt is not a vector (to create a vector from 1 to 10, you type [1:10;]). Actually, its type is\n\ntypeof(x)\n\nUnitRange{Int64}\n\n\nwith its type hierarchy\n\nBase.show_supertypes(typeof(x))\n\nUnitRange{Int64} &lt;: AbstractUnitRange{Int64} &lt;: OrdinalRange{Int64, Int64} &lt;: AbstractRange{Int64} &lt;: AbstractVector{Int64} &lt;: Any\n\n\nSo x is a much simpler object than a vector: it is a increasing sequence of integer numbers, each 1 unity bigger than the previous one. It makes sense then that the maximum function can be defined much more simpler for an object of type UnitRange{Int64}: the biggest element is always the last.\nIf you look at the sourcecode\n\n@edit maximum(1:10)\n\nyou will get\n\nmaximum(r::AbstractUnitRange) = isempty(r) ? throw(ArgumentError(\"range must be non-empty\")) : last(r)\n\nwhich is exactly what we thought.\nIn summary: Julia has an arbitrary maximum function for arbitrary vectors, but has specialized forms (methods) for some other types. This is a common pattern in Julia, and much of its performance is thanks to that."
  },
  {
    "objectID": "posts-ds/julia-for-r-users/julia-for-r-users.html#modules-and-packages-are-a-joy-to-use",
    "href": "posts-ds/julia-for-r-users/julia-for-r-users.html#modules-and-packages-are-a-joy-to-use",
    "title": "Julia for R users",
    "section": "Modules and packages are a joy to use",
    "text": "Modules and packages are a joy to use\nIn R, you have 2 options to call a function from another package:\n\nuse library(PACKAGE) and then import every function from PACKAGE to your namespace;\nuse PACKAGE::FUNCTION every time you want to use a function.\n\nPackages like box are a more “Pythonesque” approach to importing libraries.\nIn Julia, you have all these for free:\n\na\nb\nc\n\nThere is also the possibility to create modules inside modules (which are like packages inside packages). For example, if you have a package to train machine learning models, you can have a module about Metrics, another one with Models and so on. Importing then can be done with\n\nusing MyPackage.Metrics\n\n# or\nimport MyPackage.Models as MD\n\nMD.model1(etc)"
  },
  {
    "objectID": "posts-ds/julia-for-r-users/julia-for-r-users.html#the-compiler-is-your-friend",
    "href": "posts-ds/julia-for-r-users/julia-for-r-users.html#the-compiler-is-your-friend",
    "title": "Julia for R users",
    "section": "The compiler is your friend",
    "text": "The compiler is your friend\nSometimes you write code that won’t make your parents proud. Suppose you create a function that sums all the numbers from 1 to n:\n\nfunction f_sum(n)\n    s = 0\n    for i in 1:n\n        s += i\n    end\n\n    s\nend;\n\nIn R, the language will obediently execute each iteration of the loop, as you demanded. You are the boss.\nBut in Julia, we have this curious phenomena:\n\n@time f_sum(100)\n\n  0.000001 seconds\n\n\n5050\n\n\n\n@time f_sum(100_000)\n\n  0.000001 seconds\n\n\n5000050000\n\n\n\n@time f_sum(100_000_000)\n\n  0.000001 seconds\n\n\n5000000050000000\n\n\nHow is it possible that it took the same time for 100 iterations and 100 million? The magic is the compiler: it understood that what you are doing is the sum of the terms of an arithmetic progression. The legend says that Gauss deduced the formula for its sum, and the compiler did the same for you. No need to be as smart as Gauss while using Julia!\nJulia is a just-in-time (JIT) compiled language, which means that each function is compiled when you first execute it. The “time to first compile” was a problem in the past, but from Julia 1.8 onwards it is not a big deal."
  },
  {
    "objectID": "posts-ds/julia-for-r-users/julia-for-r-users.html#macros-rewrite-code-without-typing",
    "href": "posts-ds/julia-for-r-users/julia-for-r-users.html#macros-rewrite-code-without-typing",
    "title": "Julia for R users",
    "section": "Macros rewrite code without typing",
    "text": "Macros rewrite code without typing\nMacros are one of the most powerful tools in Julia. They rewrite your code before executing it: it is a metaprogramming technique. When creating macros, you will have to understand how a bunch of characters are interpreted by the language and executed as code. This means that macros can rewrite pieces of code and add functionalities that are not possible simply with functions.\nWe already used some macros on this notebook; they all start with the @ symbol.\nHow much time does it take to calculate the sin of a million numbers?\n\n@time sin.(1:1_000_000);\n\n  0.026550 seconds (2 allocations: 7.629 MiB)\n\n\nDo you have a loop and want to see a progress bar? No need to change the code inside the loop:\n\nusing ProgressMeter;\n\n@showprogress for i in 1:10\n    sleep(0.1)\nend\n\nProgress:  20%|████████▎                                |  ETA: 0:00:07Progress:  90%|████████████████████████████████████▉    |  ETA: 0:00:00Progress: 100%|█████████████████████████████████████████| Time: 0:00:03\n\n\nAs we’ve seen, even the tidyverse could be recreated in Julia using macros!"
  },
  {
    "objectID": "posts-ds/julia-for-r-users/julia-for-r-users.html#multithreading-is-trivial",
    "href": "posts-ds/julia-for-r-users/julia-for-r-users.html#multithreading-is-trivial",
    "title": "Julia for R users",
    "section": "Multithreading is trivial",
    "text": "Multithreading is trivial"
  },
  {
    "objectID": "posts-ds/julia-for-r-users/julia-for-r-users.html#you-can-run-r-inside-of-julia",
    "href": "posts-ds/julia-for-r-users/julia-for-r-users.html#you-can-run-r-inside-of-julia",
    "title": "Julia for R users",
    "section": "You can run R inside of Julia",
    "text": "You can run R inside of Julia\nNot sure where to begin in Julia? Start with R!\n\nusing RCall;\n\nR\"\"\"\nmedian(1:5)\n\"\"\"\n\nRObject{IntSxp}\n[1] 3\n\n\nYou can even pass objects from Julia to R:\n\nx = [1:5;]\n\n@rput x\n\nR\"median(x)\"\n\nRObject{IntSxp}\n[1] 3\n\n\nThis quarto notebook is actually run using RCall! See RCall docs for more details.\nYou can see some differences between R and Julia here."
  },
  {
    "objectID": "posts-ds/julia-for-r-users/julia-for-r-users.html#there-is-a-tidyverse-in-julia-and-it-is-awesome",
    "href": "posts-ds/julia-for-r-users/julia-for-r-users.html#there-is-a-tidyverse-in-julia-and-it-is-awesome",
    "title": "Julia for R users",
    "section": "There is a tidyverse in Julia and it is awesome",
    "text": "There is a tidyverse in Julia and it is awesome\nTidier.jl is a data analysis package inspired by R’s tidyverse and crafted specifically for Julia. It is made with the macro magic described below. Behind the scenes, it is transformed in usual Dataframes.jl code.\n\n\n\nWhy not recreate an entire ecosystem using macros?\n\n\nHere’s an example from TidierData docs:\n\nusing TidierData\nusing RDatasets\n\nmovies = dataset(\"ggplot2\", \"movies\");\n\n@chain movies begin\n    @mutate(Budget = Budget / 1_000_000)\n    @filter(Budget &gt;= mean(skipmissing(Budget)))\n    @select(Title, Budget)\n    @slice(1:5)\nend\n\nIt looks like dplyr code with @s."
  },
  {
    "objectID": "posts-ds/julia-for-r-users/julia-for-r-users.html#multiple-dispatch-and-type-system",
    "href": "posts-ds/julia-for-r-users/julia-for-r-users.html#multiple-dispatch-and-type-system",
    "title": "Julia for R users",
    "section": "Multiple dispatch and type system",
    "text": "Multiple dispatch and type system\nA type system is a way to organize data types within an hierarchy. Think of it as mathematical sets: you have the real numbers, and inside it are the rationals, the integers and so on. Each one of these types store data into memory in a different manner (integers can be stored more efficiently than arbitrary real numbers, for example). Julia has a really nice type system. Let’s see some examples to better understand it.\nConsider the print function in R. It is a generic function, which means that its behaviour depends on the class/type of its first argument. This can be seen when we look to its misterious source code:\n\n\n\nThe print function sourcecode.\n\n\nwhich means that print will use several methods (implementations/pieces-of-code), one for each class/type. Actually, R just creates a different function for each class, with the pattern {function}.{class}:\n\n\n\nEach method/implementation of the generic function print.\n\n\nIn Julia, every function is generic. This means that we can use the same function name and define different behaviours/implementations for each combination of classes/types of its arguments. We saw above the implementation of the maximum function in Julia for an arbitrary vector of numbers. But what if the vector is of a different kind, which is easier to determine the maximum?\nTake, for example, the object\n\nx = 1:10\n\n1:10\n\n\nIt is not a vector (to create a usual vector from 1 to 10, you type [1:10;]). Actually, its type is\n\ntypeof(x)\n\nUnitRange{Int64}\n\n\nand its type hierarchy is\n\nBase.show_supertypes(typeof(x))\n\nUnitRange{Int64} &lt;: AbstractUnitRange{Int64} &lt;: OrdinalRange{Int64, Int64} &lt;: AbstractRange{Int64} &lt;: AbstractVector{Int64} &lt;: Any\n\n\nSo x is a much simpler object than a vector: it is an increasing sequence of integer numbers, each 1 unity bigger than the previous one. It makes sense then that the maximum function can be defined much more simpler for an object of type UnitRange{Int64}: the biggest element is always the last.\nIf you look at the sourcecode\n\n@edit maximum(1:10)\n\nyou will get\n\nmaximum(r::AbstractUnitRange) = isempty(r) ? throw(ArgumentError(\"range must be non-empty\")) : last(r)\n\nwhich is exactly what we thought. The function last is defined for every element children of type AbstractUnitRange, and so maximum is well defined and performant.\nIn summary: Julia has an arbitrary maximum function for arbitrary vectors, but has specialized methods for some other specific types. This is a common pattern in Julia, and much of its performance depends on this."
  },
  {
    "objectID": "posts-ds/julia-for-r-users/julia-for-r-users.html#math-symbols-for-the-math-enthusiasts",
    "href": "posts-ds/julia-for-r-users/julia-for-r-users.html#math-symbols-for-the-math-enthusiasts",
    "title": "Julia for R users",
    "section": "Math symbols for the math enthusiasts",
    "text": "Math symbols for the math enthusiasts\nExamples of correct Julia code:\n\n[1, 2] ∩ [2, 3]\n\n1-element Vector{Int64}:\n 2\n\n\n\n2 ∈ [2, 3]\n\ntrue\n\n\n\nf(r) = π*r^2\n\nf(3)\n\n28.274333882308138\n\n\n\n# Euler's identity\nℯ^(im * π) + 1 |&gt; round\n\n0.0 + 0.0im"
  }
]